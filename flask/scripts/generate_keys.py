#!/usr/bin/env python3
"""
ESP32 OTA Security Key Generator
================================

Generates RSA-2048 key pair and AES-256 key for secure firmware updates.
Creates C header file with embedded keys for ESP32 project.

Usage:
    python3 generate_keys.py

Generated Files:
    keys/server_private_key.pem - RSA private key (KEEP SECURE!)
    keys/server_public_key.pem  - RSA public key
    keys/aes_firmware_key.bin   - AES-256 key (KEEP SECURE!)
    keys/keys.h                 - C header for ESP32 project
"""

import os
import secrets
from pathlib import Path
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend


class SecurityKeyGenerator:
    """Generates and manages cryptographic keys for ESP32 OTA updates."""
    
    def __init__(self, keys_dir="./keys"):
        self.keys_dir = Path(keys_dir)
        self.keys_dir.mkdir(exist_ok=True)
        
        # File paths
        self.private_key_path = self.keys_dir / "server_private_key.pem"
        self.public_key_path = self.keys_dir / "server_public_key.pem"
        self.aes_key_path = self.keys_dir / "aes_firmware_key.bin"
        self.header_path = self.keys_dir / "keys.h"
        
    def generate_rsa_keypair(self):
        """Generate RSA-2048 key pair for digital signatures."""
        print("ğŸ” Generating RSA-2048 key pair...")
        
        # Generate private key
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # Get public key
        public_key = private_key.public_key()
        
        # Serialize private key (PEM format)
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        # Serialize public key (PEM format)
        public_pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        # Save to files
        with open(self.private_key_path, 'wb') as f:
            f.write(private_pem)
        print(f"   âœ… Private key saved: {self.private_key_path}")
        
        with open(self.public_key_path, 'wb') as f:
            f.write(public_pem)
        print(f"   âœ… Public key saved: {self.public_key_path}")
        
        return private_pem, public_pem
    
    def generate_aes_key(self):
        """Generate AES-256 key for firmware encryption."""
        print("ğŸ” Generating AES-256 encryption key...")
        
        # Generate 256-bit (32 bytes) random key
        aes_key = secrets.token_bytes(32)
        
        # Save to binary file
        with open(self.aes_key_path, 'wb') as f:
            f.write(aes_key)
        print(f"   âœ… AES key saved: {self.aes_key_path}")
        
        return aes_key
    
    def generate_hmac_psk(self):
        """Generate pre-shared key for HMAC authentication."""
        print("ğŸ” Generating HMAC pre-shared key...")
        
        # Generate 256-bit PSK as hex string
        psk_bytes = secrets.token_bytes(32)
        psk_hex = psk_bytes.hex()
        print(f"   âœ… HMAC PSK generated: {len(psk_hex)} characters")
        
        return psk_hex
    
    def create_esp32_header(self, public_pem, aes_key, hmac_psk):
        """Create C header file with embedded keys for ESP32."""
        print("ğŸ“„ Creating ESP32 C header file...")
        
        # Convert PEM to C string with escaped newlines
        public_key_str = public_pem.decode('utf-8').replace('\n', '\\n')
        
        # Convert AES key to C array format
        aes_array = ', '.join([f'0x{byte:02X}' for byte in aes_key])
        
        # Create header content
        header_content = f'''/*
 * ESP32 OTA Security Keys
 * Auto-generated by generate_keys.py
 * 
 * âš ï¸  SECURITY WARNING: These keys are embedded in firmware!
 * âš ï¸  In production, use secure key storage (efuse, secure boot, etc.)
 */

#ifndef OTA_KEYS_H
#define OTA_KEYS_H

#include <stdint.h>

// RSA-2048 Public Key for signature verification
const char* SERVER_PUBLIC_KEY = 
    "{public_key_str}";

// AES-256 Key for firmware decryption (32 bytes)
const uint8_t AES_FIRMWARE_KEY[32] = {{
    {aes_array}
}};

// HMAC Pre-Shared Key for chunk authentication
const char* HMAC_PSK = "{hmac_psk}";

// Key metadata
#define RSA_KEY_SIZE 2048
#define AES_KEY_SIZE 256
#define HMAC_PSK_SIZE 64

#endif // OTA_KEYS_H
'''
        
        # Save header file
        with open(self.header_path, 'w') as f:
            f.write(header_content)
        print(f"   âœ… C header saved: {self.header_path}")
        
        return header_content
    
    def generate_all_keys(self):
        """Generate complete key set for OTA system."""
        print("ğŸš€ ESP32 OTA Security Key Generation")
        print("=" * 50)
        
        try:
            # Generate RSA key pair
            private_pem, public_pem = self.generate_rsa_keypair()
            
            # Generate AES key
            aes_key = self.generate_aes_key()
            
            # Generate HMAC PSK
            hmac_psk = self.generate_hmac_psk()
            
            # Create ESP32 header
            self.create_esp32_header(public_pem, aes_key, hmac_psk)
            
            print("\nğŸ‰ KEY GENERATION COMPLETE!")
            print("=" * 50)
            
            # Display security information
            self._display_security_info()
            
            # Display next steps
            self._display_next_steps()
            
            return True
            
        except Exception as e:
            print(f"âŒ Error generating keys: {e}")
            return False
    
    def _display_security_info(self):
        """Display security information and warnings."""
        print("\nğŸ”’ SECURITY INFORMATION:")
        print("   ğŸ“‹ RSA-2048 keys: Digital signature verification")
        print("   ğŸ“‹ AES-256 key: Firmware encryption/decryption")
        print("   ğŸ“‹ HMAC PSK: Per-chunk authentication")
        print("\nâš ï¸  SECURITY WARNINGS:")
        print("   ğŸš¨ Keep private keys SECURE and BACKED UP!")
        print("   ğŸš¨ Never commit private keys to version control!")
        print("   ğŸš¨ In production, use hardware security modules!")
        print("   ğŸš¨ Keys embedded in firmware can be extracted!")
    
    def _display_next_steps(self):
        """Display next implementation steps."""
        print("\nğŸ“‹ NEXT STEPS:")
        print("   1ï¸âƒ£  Copy keys/keys.h to ESP32 project include/ directory")
        print("   2ï¸âƒ£  Create firmware_manager.py for firmware preparation") 
        print("   3ï¸âƒ£  Add OTA endpoints to Flask server")
        print("   4ï¸âƒ£  Implement OTAManager class in ESP32 project")
        print("\nğŸ“ FILES GENERATED:")
        print(f"   ğŸ“„ {self.private_key_path} (PRIVATE - keep secure!)")
        print(f"   ğŸ“„ {self.public_key_path}")
        print(f"   ğŸ“„ {self.aes_key_path} (PRIVATE - keep secure!)")
        print(f"   ğŸ“„ {self.header_path} (Copy to ESP32 project)")


def main():
    """Main execution function."""
    print("ESP32 OTA Security Key Generator")
    print("Generating cryptographic keys for secure firmware updates...\n")
    
    # Create key generator
    generator = SecurityKeyGenerator()
    
    # Check if keys already exist
    if any(path.exists() for path in [
        generator.private_key_path, 
        generator.public_key_path, 
        generator.aes_key_path
    ]):
        response = input("âš ï¸  Keys already exist! Regenerate? (y/N): ").lower()
        if response != 'y':
            print("âŒ Key generation cancelled.")
            return
        print("ğŸ”„ Regenerating keys...")
    
    # Generate keys
    success = generator.generate_all_keys()
    
    if success:
        print("\nâœ… Ready to proceed with firmware_manager.py implementation!")
    else:
        print("\nâŒ Key generation failed! Check error messages above.")


if __name__ == "__main__":
    main()