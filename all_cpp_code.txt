// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/application/compression.cpp =====
#include "application/compression.h"

// ==================== STATIC MEMBER INITIALIZATION ====================

String DataCompression::lastErrorMessage = "";
DataCompression::ErrorType DataCompression::lastErrorType = ERROR_NONE;
bool DataCompression::debugMode = false;
size_t DataCompression::maxMemoryUsage = DEFAULT_MAX_MEMORY;
float DataCompression::compressionPreference = DEFAULT_PREFERENCE;
uint16_t DataCompression::largeDeltaThreshold = DEFAULT_LARGE_DELTA_THRESHOLD;
uint8_t DataCompression::bitPackingThreshold = DEFAULT_BIT_PACKING_THRESHOLD;
float DataCompression::dictionaryLearningRate = DEFAULT_DICTIONARY_LEARNING_RATE;
uint8_t DataCompression::temporalWindowSize = DEFAULT_TEMPORAL_WINDOW_SIZE;

// Working memory buffer variables
uint8_t* DataCompression::workingBuffer = nullptr;
size_t DataCompression::workingBufferSize = 0;
bool DataCompression::workingBufferAllocated = false;

// Performance tracking variables
unsigned long DataCompression::totalCompressions = 0;
unsigned long DataCompression::totalDecompressions = 0;
float DataCompression::cumulativeCompressionRatio = 0.0f;
unsigned long DataCompression::cumulativeCompressionTime = 0;

// Smart Selection variables
DataCompression::SensorPattern DataCompression::sensorDictionary[16] = {};
uint8_t DataCompression::dictionarySize = 0;
uint32_t DataCompression::smartTotalCompressions = 0;
DataCompression::TemporalContext DataCompression::temporalBuffer = {};
DataCompression::MethodPerformance DataCompression::methodStats[4] = {
    {"DICTIONARY", 0, 0.0f, 0, 0.0f, 0.0f},
    {"TEMPORAL", 0, 0.0f, 0, 0.0f, 0.0f},
    {"SEMANTIC", 0, 0.0f, 0, 0.0f, 0.0f},
    {"BITPACK", 0, 0.0f, 0, 0.0f, 0.0f}
};

// Method identifiers
const char* DataCompression::METHOD_BINARY_PACKED = "BINPACK";
const char* DataCompression::METHOD_BINARY_DELTA = "BINDELTA";
const char* DataCompression::METHOD_BINARY_RLE = "BINRLE";
const char* DataCompression::METHOD_BINARY_HYBRID = "BINHYBRID";
const char* DataCompression::METHOD_RAW_BINARY = "RAWBIN";

// ==================== ADAPTIVE SMART SELECTION METHODS ====================

/**
 * @fn std::vector<uint8_t> DataCompression::compressWithSmartSelection(uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Compress data using the adaptive smart selection system.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> DataCompression::compressWithSmartSelection(uint16_t* data, const RegID* selection, size_t count) 
{
    if (count == 0 || data == nullptr || selection == nullptr) 
    {
        setError("Invalid input for smart selection", ERROR_INVALID_INPUT);
        return std::vector<uint8_t>();
    }
    
    unsigned long startTime = micros();
    
    // Initialize dictionary if needed
    if (dictionarySize == 0) 
    {
        initializeSensorDictionary();
    }
    
    // Test all compression methods
    auto dictionaryResult = testCompressionMethod("DICTIONARY", data, selection, count);
    auto temporalResult = testCompressionMethod("TEMPORAL", data, selection, count);
    auto semanticResult = testCompressionMethod("SEMANTIC", data, selection, count);
    auto bitpackResult = testCompressionMethod("BITPACK", data, selection, count);
    
    // Find the best result (lowest compression ratio = best compression)
    std::vector<CompressionResult> results = {dictionaryResult, temporalResult, semanticResult, bitpackResult};
    
    CompressionResult bestResult = results[0];
    for (const auto& result : results) 
    {
        if (result.academicRatio < bestResult.academicRatio && result.academicRatio > 0) 
        {
            bestResult = result;
        }
    }
    
    // Update adaptive learning
    updateMethodPerformance(bestResult.method, bestResult.academicRatio, bestResult.timeUs);
    
    unsigned long totalTime = micros() - startTime;
    
    // Print original vs compressed data clearly
    size_t originalBytes = count * sizeof(uint16_t);
    size_t compressedBytes = bestResult.data.size();
    float savingsPercent = (1.0f - bestResult.academicRatio) * 100.0f;
    
    print("COMPRESSION RESULT: %s method\n", bestResult.method.c_str());
    print("Original: %zu bytes -> Compressed: %zu bytes (%.1f%% savings)\n", 
          originalBytes, compressedBytes, savingsPercent);
    print("Academic Ratio: %.3f | Time: %lu μs\n", bestResult.academicRatio, totalTime);

    // Update dictionary with new data for future improvements
    updateDictionary(data, selection, count);
    
    return bestResult.data;
}


/**
 * @fn DataCompression::CompressionResult DataCompression::testCompressionMethod(const String& method, uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Test an individual compression method and return detailed results.
 * 
 * @param method Compression method to test ("DICTIONARY", "TEMPORAL", "SEMANTIC", "BITPACK").
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * 
 * @return CompressionResult Struct containing compressed data and performance metrics.
 */
DataCompression::CompressionResult DataCompression::testCompressionMethod(const String& method, uint16_t* data, const RegID* selection, size_t count) 
{
    CompressionResult result;
    unsigned long startTime = micros();
    
    if (method == "DICTIONARY") 
    {
        result.data = compressWithDictionary(data, selection, count);
    } 
    else if (method == "TEMPORAL") 
    {
        result.data = compressWithTemporalDelta(data, selection, count);
    } 
    else if (method == "SEMANTIC") 
    {
        result.data = compressWithSemanticRLE(data, selection, count);
    } 
    else if (method == "BITPACK") 
    {
        result.data = compressBinary(data, count);
    }
    
    result.timeUs = micros() - startTime;
    result.method = method;
    
    // Calculate academic compression ratio (compressed/original)
    size_t originalBits = count * 16;  // 16 bits per uint16_t
    size_t compressedBits = result.data.size() * 8;  // 8 bits per byte
    
    result.academicRatio = result.data.empty() ? 1.0f : (float)compressedBits / (float)originalBits;
    result.traditionalRatio = result.data.empty() ? 0.0f : (float)originalBits / (float)compressedBits;
    result.efficiency = result.academicRatio > 0 ? (1.0f / result.academicRatio) / (result.timeUs / 1000.0f) : 0.0f;
    
    return result;
}

// ==================== DICTIONARY-BASED BITMASK COMPRESSION ====================

/**
 * @fn std::vector<uint8_t> DataCompression::compressWithDictionary(uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Compress data using dictionary-based bitmask compression.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> DataCompression::compressWithDictionary(uint16_t* data, const RegID* selection, size_t count) 
{
    std::vector<uint8_t> result;
    
    // Find closest dictionary pattern
    int bestMatch = findClosestDictionaryPattern(data, selection, count);
    
    if (bestMatch >= 0) 
    {
        // Bitmask compression with dictionary
        result.push_back(0xD0);  // Dictionary compression marker
        result.push_back(bestMatch);  // Dictionary index
        result.push_back(count);  // Number of values
        
        // Create bitmask for differences and collect deltas
        uint16_t differencesMask = 0;
        std::vector<int16_t> deltas;
        uint8_t deltaBits = 0;
        
        for (size_t i = 0; i < count; i++) 
        {
            int16_t delta = (int16_t)data[i] - (int16_t)sensorDictionary[bestMatch].values[selection[i]];
            if (delta != 0) 
            {
                differencesMask |= (1 << i);
                deltas.push_back(delta);
            }
        }
        
        // Store bitmask (up to 16 bits for max 16 registers)
        result.push_back(differencesMask & 0xFF);
        result.push_back((differencesMask >> 8) & 0xFF);
        
        // Encode deltas using variable-length encoding
        for (int16_t delta : deltas) 
        {
            if (delta >= -127 && delta <= 127) 
            {
                // 8-bit signed delta
                result.push_back(0x80 | ((uint8_t)delta & 0x7F));
                if (delta < 0) result[result.size()-1] |= 0x40;  // Sign bit
            } 
            else 
            {
                // 16-bit delta with escape marker
                result.push_back(0x00);  // 16-bit marker
                result.push_back(delta & 0xFF);
                result.push_back((delta >> 8) & 0xFF);
            }
        }
    } 
    else 
    {
        // No good dictionary match, fall back to bit-packing
        return compressBinary(data, count);
    }
    
    return result;
}

// ==================== TEMPORAL DELTA COMPRESSION ====================
/**
 * @fn std::vector<uint8_t> DataCompression::compressWithTemporalDelta(uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Compress data using temporal delta compression with trend analysis.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> DataCompression::compressWithTemporalDelta(uint16_t* data, const RegID* selection, size_t count) 
{
    std::vector<uint8_t> result;
    
    // Check if we have temporal context and matching register layout
    bool hasCompatibleHistory = temporalBuffer.bufferFull && 
                               temporalBuffer.lastRegisterCount == count &&
                               memcmp(temporalBuffer.lastRegisters, selection, count * sizeof(RegID)) == 0;
    
    if (!hasCompatibleHistory) 
    {
        // Store as base sample
        result.push_back(0x70);  // Temporal base marker
        result.push_back(count);
        
        // Store register layout
        for (size_t i = 0; i < count; i++) 
        {
            result.push_back(selection[i]);
        }
        
        // Store values
        for (size_t i = 0; i < count; i++) 
        {
            result.push_back(data[i] & 0xFF);
            result.push_back((data[i] >> 8) & 0xFF);
        }
    } 
    else 
    {
        // Use temporal prediction with trend analysis
        result.push_back(0x71);  // Temporal delta marker
        result.push_back(count);
        
        uint8_t prevIndex = (temporalBuffer.writeIndex - 1 + 8) % 8;
        uint8_t prev2Index = (temporalBuffer.writeIndex - 2 + 8) % 8;
        
        for (size_t i = 0; i < count; i++) 
        {
            // Linear prediction: predict[i] = 2*prev[i] - prev2[i]
            int32_t prev1 = temporalBuffer.recentSamples[prevIndex][selection[i]];
            int32_t prev2 = temporalBuffer.recentSamples[prev2Index][selection[i]];
            int32_t predicted = 2 * prev1 - prev2;
            
            // Clamp prediction to reasonable range
            if (predicted < 0) predicted = prev1;
            if (predicted > 65535) predicted = prev1;
            
            int16_t delta = (int16_t)data[i] - (int16_t)predicted;
            
            // Variable-length delta encoding
            if (delta >= -63 && delta <= 63) 
            {
                // 7-bit delta with sign
                uint8_t encoded = (abs(delta) & 0x3F) | 0x80;
                if (delta < 0) encoded |= 0x40;
                result.push_back(encoded);
            } 
            else if (delta >= -127 && delta <= 127) 
            {
                // 8-bit delta  
                result.push_back(0x00);  // 8-bit marker
                result.push_back((uint8_t)delta);
            } 
            else 
            {
                // 16-bit delta
                result.push_back(0x01);  // 16-bit marker
                result.push_back(delta & 0xFF);
                result.push_back((delta >> 8) & 0xFF);
            }
        }
    }
    
    // Update temporal buffer
    for (size_t i = 0; i < count; i++) 
    {
        temporalBuffer.recentSamples[temporalBuffer.writeIndex][selection[i]] = data[i];
    }
    memcpy(temporalBuffer.lastRegisters, selection, count * sizeof(RegID));
    temporalBuffer.lastRegisterCount = count;
    temporalBuffer.writeIndex = (temporalBuffer.writeIndex + 1) % 8;
    if (temporalBuffer.writeIndex == 0) temporalBuffer.bufferFull = true;
    
    return result;
}

// ==================== SEMANTIC RLE COMPRESSION ====================
/**
 * @fn std::vector<uint8_t> DataCompression::compressWithSemanticRLE(uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Compress data using semantic run-length encoding (RLE) with type-aware encoding.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> DataCompression::compressWithSemanticRLE(uint16_t* data, const RegID* selection, size_t count) 
{
    std::vector<uint8_t> result;
    result.push_back(0x50);  // Semantic RLE marker
    result.push_back(count);
    
    // Group registers by semantic type
    struct RegisterGroup 
    {
        std::vector<uint16_t> values;
        std::vector<uint8_t> positions;
        String type;
        uint8_t typeId;
    };
    
    std::vector<RegisterGroup> groups;
    
    // Classify and group registers
    for (size_t i = 0; i < count; i++) 
    {
        char regType[16];
        getRegisterType(selection[i], regType, sizeof(regType));
        uint8_t typeId = getRegisterTypeId(selection[i]);
        
        // Find existing group or create new one
        bool found = false;
        for (auto& group : groups) 
        {
            if (group.typeId == typeId) 
            {
                group.values.push_back(data[i]);
                group.positions.push_back(i);
                found = true;
                break;
            }
        }
        
        if (!found) 
        {
            RegisterGroup newGroup;
            newGroup.type = regType;
            newGroup.typeId = typeId;
            newGroup.values.push_back(data[i]);
            newGroup.positions.push_back(i);
            groups.push_back(newGroup);
        }
    }
    
    result.push_back(groups.size());  // Number of semantic groups
    
    // Compress each group with type-specific RLE
    for (const auto& group : groups) 
    {
        result.push_back(group.typeId);  // Type identifier
        result.push_back(group.values.size());  // Group size
        
        // Store positions
        for (uint8_t pos : group.positions) 
        {
            result.push_back(pos);
        }
        
        // Apply RLE with type-aware encoding
        size_t i = 0;
        while (i < group.values.size()) 
        {
            uint16_t currentValue = group.values[i];
            uint8_t runLength = 1;
            
            // Count consecutive similar values (with tolerance for same type)
            uint16_t tolerance = getTypeTolerances(group.typeId);
            
            while (i + runLength < group.values.size() && runLength < 255) 
            {
                if (abs((int32_t)group.values[i + runLength] - (int32_t)currentValue) <= tolerance) 
                {
                    runLength++;
                } 
                else 
                {
                    break;
                }
            }
            
            // Store run with type-specific bit packing
            uint8_t bitsNeeded = getBitsForType(group.typeId);
            if (bitsNeeded <= 8) 
            {
                result.push_back(currentValue & 0xFF);
                result.push_back(runLength);
            } else {
                result.push_back(currentValue & 0xFF);
                result.push_back((currentValue >> 8) & 0xFF);
                result.push_back(runLength);
            }
            
            i += runLength;
        }
    }
    
    return result;
}

// ==================== HELPER FUNCTIONS ====================
/**
 * @fn DataCompression::getRegisterType(RegID regId, char* result, size_t resultSize)
 * 
 * @brief Get the semantic type string for a given register ID.
 * 
 * @param regId Register ID to classify.
 * @param result Buffer to store the resulting type string.
 * @param resultSize Size of the result buffer.
 */
void DataCompression::getRegisterType(RegID regId, char* result, size_t resultSize) 
{
    const char* typeStr;
    switch (regId) 
    {
        case REG_VAC1: typeStr = "voltage"; break;
        case REG_IAC1: typeStr = "current"; break;
        case REG_FAC1: typeStr = "frequency"; break;
        case REG_VPV1:
        case REG_VPV2: typeStr = "pv_voltage"; break;
        case REG_IPV1:
        case REG_IPV2: typeStr = "pv_current"; break;
        case REG_TEMP: typeStr = "temperature"; break;
        case REG_POW:
        case REG_PAC: typeStr = "power"; break;
        default: typeStr = "unknown"; break;
    }
    strncpy(result, typeStr, resultSize - 1);
    result[resultSize - 1] = '\0';
}


/**
 * @fn uint8_t DataCompression::getRegisterTypeId(RegID regId)
 * 
 * @brief Get a numeric type identifier for a given register ID.
 * 
 * @param regId Register ID to classify.
 * 
 * @return uint8_t Numeric type identifier (1-7), or 0 for unknown.
 */
uint8_t DataCompression::getRegisterTypeId(RegID regId) 
{
    switch (regId) 
    {
        case REG_VAC1: return 1;  // AC voltage
        case REG_IAC1: return 2;  // AC current
        case REG_FAC1: return 3;  // Frequency
        case REG_VPV1:
        case REG_VPV2: return 4;  // PV voltage
        case REG_IPV1:
        case REG_IPV2: return 5;  // PV current
        case REG_TEMP: return 6;  // Temperature
        case REG_POW:
        case REG_PAC: return 7;   // Power
        default: return 0;        // Unknown
    }
}

/**
 * @fn uint16_t DataCompression::getTypeTolerances(uint8_t typeId)
 * 
 * @brief Get the tolerance value for a given semantic type ID.
 * 
 * @param typeId Numeric type identifier (1-7).
 * 
 * @return uint16_t Tolerance value for the type.
 */
uint16_t DataCompression::getTypeTolerances(uint8_t typeId) 
{
    switch (typeId) 
    {
        case 1: return 10;  // AC voltage ±10V
        case 2: return 5;   // AC current ±5A
        case 3: return 1;   // Frequency ±1Hz
        case 4: return 15;  // PV voltage ±15V
        case 5: return 3;   // PV current ±3A
        case 6: return 5;   // Temperature ±5°C
        case 7: return 50;  // Power ±50W
        default: return 0;
    }
}

/**
 * @fn uint8_t DataCompression::getBitsForType(uint8_t typeId)
 * 
 * @brief Get the number of bits needed to represent a given semantic type ID.
 * 
 * @param typeId Numeric type identifier (1-7).
 * 
 * @return uint8_t Number of bits needed for the type.
 */
uint8_t DataCompression::getBitsForType(uint8_t typeId) 
{
    switch (typeId) 
    {
        case 1: return 12;  // AC voltage (0-4095V)
        case 2: return 8;   // AC current (0-255A)
        case 3: return 6;   // Frequency (0-63Hz)
        case 4: return 9;   // PV voltage (0-511V)
        case 5: return 7;   // PV current (0-127A)
        case 6: return 10;  // Temperature (0-1023°C)
        case 7: return 13;  // Power (0-8191W)
        default: return 16;
    }
}


/**
 * @fn void DataCompression::initializeSensorDictionary()
 * 
 * @brief Initialize the sensor dictionary with common patterns.
 */
void DataCompression::initializeSensorDictionary() 
{
    // Pattern 0: Typical daytime operation
    uint16_t pattern0[] = {2400, 170, 50, 400, 380, 70, 65, 550, 4000, 4200};
    memcpy(sensorDictionary[0].values, pattern0, sizeof(pattern0));
    sensorDictionary[0].frequency = 1;
    
    // Pattern 1: Low power operation
    uint16_t pattern1[] = {2380, 100, 50, 200, 180, 30, 25, 520, 2000, 2500};
    memcpy(sensorDictionary[1].values, pattern1, sizeof(pattern1));
    sensorDictionary[1].frequency = 1;
    
    // Pattern 2: High power operation  
    uint16_t pattern2[] = {2450, 200, 50, 450, 420, 90, 85, 580, 5000, 5200};
    memcpy(sensorDictionary[2].values, pattern2, sizeof(pattern2));
    sensorDictionary[2].frequency = 1;
    
    // Pattern 3: Your typical current readings (learned from data)
    uint16_t pattern3[] = {2430, 165, 50, 350, 350, 70, 65, 545, 4100, 4150};
    memcpy(sensorDictionary[3].values, pattern3, sizeof(pattern3));
    sensorDictionary[3].frequency = 1;
    
    dictionarySize = 4;
}


/**
 * @fn int DataCompression::findClosestDictionaryPattern(uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Find the closest matching pattern in the dictionary for the given data.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * 
 * @return int Index of the closest matching pattern, or -1 if no good match found.
 */
int DataCompression::findClosestDictionaryPattern(uint16_t* data, const RegID* selection, size_t count) 
{
    if (dictionarySize == 0) return -1;
    
    int bestMatch = -1;
    uint32_t minDistance = UINT32_MAX;
    
    for (uint8_t i = 0; i < dictionarySize; i++) 
    {
        uint32_t distance = 0;
        
        for (size_t j = 0; j < count; j++) 
        {
            int32_t diff = (int32_t)data[j] - (int32_t)sensorDictionary[i].values[selection[j]];
            distance += abs(diff);
        }
        
        if (distance < minDistance) 
        {
            minDistance = distance;
            bestMatch = i;
        }
    }
    
    // Use dictionary if average error per value is reasonable
    uint32_t avgError = minDistance / count;
    if (avgError < 200) 
    {  // Threshold for acceptable match
        return bestMatch;
    }
    
    return -1;  // No good match
}

/**
 * @fn void DataCompression::updateDictionary(uint16_t* data, const RegID* selection, size_t count)
 * 
 * @brief Update the sensor dictionary with a new pattern if it's unique enough.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 */
void DataCompression::updateDictionary(uint16_t* data, const RegID* selection, size_t count) 
{
    // Simple dictionary learning: if we have space and this pattern is unique enough
    if (dictionarySize < 15) 
    {  // Leave room for one more pattern
        int closestMatch = findClosestDictionaryPattern(data, selection, count);
        if (closestMatch < 0) 
        {  // No close match found
            // Add this as a new pattern
            for (size_t i = 0; i < count; i++) 
            {
                sensorDictionary[dictionarySize].values[selection[i]] = data[i];
            }
            sensorDictionary[dictionarySize].frequency = 1;
            dictionarySize++;
        } 
        else 
        {
            // Update frequency of existing pattern
            sensorDictionary[closestMatch].frequency++;
        }
    }
}


/**
 * @fn void DataCompression::updateMethodPerformance(const String& method, float academicRatio, unsigned long timeUs)
 * 
 * @brief Update performance statistics for a given compression method.
 * 
 * @param method Compression method name ("DICTIONARY", "TEMPORAL", "SEMANTIC", "BITPACK").
 * @param academicRatio Academic compression ratio achieved (compressed/original).
 * @param timeUs Time taken for compression in microseconds.
 */
void DataCompression::updateMethodPerformance(const String& method, float academicRatio, unsigned long timeUs) {
    for (auto& stat : methodStats) {
        if (stat.methodName == method) {
            stat.useCount++;
            stat.avgCompressionRatio = (stat.avgCompressionRatio * (stat.useCount - 1) + academicRatio) / stat.useCount;
            stat.avgTimeUs = (stat.avgTimeUs * (stat.useCount - 1) + timeUs) / stat.useCount;
            
            // Success rate: compression ratio < 0.8 is considered successful
            if (academicRatio < 0.8f) {
                stat.successRate = (stat.successRate * (stat.useCount - 1) + 1.0f) / stat.useCount;
            } else {
                stat.successRate = (stat.successRate * (stat.useCount - 1) + 0.0f) / stat.useCount;
            }
            
            // Calculate adaptive score (lower is better for academic ratio)
            stat.adaptiveScore = stat.successRate / (stat.avgCompressionRatio + 0.1f);
            break;
        }
    }
}

// ==================== EXISTING BINARY COMPRESSION METHODS ====================
/**
 * @fn std::vector<uint8_t> DataCompression::compressBinary(uint16_t* data, size_t count)
 * 
 * @brief Compress binary data using adaptive selection of methods.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param count Number of data points (length of data array).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> DataCompression::compressBinary(uint16_t* data, size_t count) 
{
    if (count == 0 || data == nullptr) 
    {
        setError("Invalid input data");
        return std::vector<uint8_t>();
    }

    DataCharacteristics characteristics = analyzeData(data, count);
    
    std::vector<uint8_t> bestResult;
    String bestMethod = "RAW_BINARY";
    size_t originalSize = count * 2;
    
    // Try bit-packing if it can save significant space
    if (characteristics.optimalBits < 16 && characteristics.optimalBits >= 8) 
    {
        std::vector<uint8_t> bitPacked = compressBinaryBitPacked(data, count, characteristics.optimalBits);
        
        if (bitPacked.size() < originalSize) 
        {
            bestResult = bitPacked;
            bestMethod = "BIT_PACKED";
        }
    }
    
    // If no compression helped, use raw binary
    if (bestResult.empty() || bestResult.size() >= originalSize) 
    {
        return storeAsRawBinary(data, count);
    }
    
    return bestResult;
}


/**
 * @fn std::vector<uint8_t> DataCompression::compressBinaryBitPacked(uint16_t* data, size_t count, uint8_t bitsPerValue)
 * 
 * @brief Compress binary data using bit-packing.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param count Number of data points (length of data array).
 * @param bitsPerValue Number of bits needed to represent each value.
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> DataCompression::compressBinaryBitPacked(uint16_t* data, size_t count, uint8_t bitsPerValue) 
{
    std::vector<uint8_t> result;
    
    if (bitsPerValue == 0 || bitsPerValue > 16) 
    {
        setError("Invalid bits per value");
        return result;
    }
    
    size_t totalBits = count * bitsPerValue;
    size_t packedBytes = (totalBits + 7) / 8;
    size_t originalBytes = count * 2;
    
    // For small datasets, skip header if it negates compression benefit
    bool useHeader = (count > 8) || (packedBytes + 3 < originalBytes);
    
    if (useHeader) 
    {
        result.push_back(0x01);  // Binary bit-packed method ID
        result.push_back(bitsPerValue);
        result.push_back(count);
    }
    
    std::vector<uint8_t> packedData(packedBytes, 0);
    
    size_t bitOffset = 0;
    for (size_t i = 0; i < count; i++) 
    {
        packBitsIntoBuffer(data[i], packedData.data(), bitOffset, bitsPerValue);
        bitOffset += bitsPerValue;
    }
    
    result.insert(result.end(), packedData.begin(), packedData.end());
    return result;
}


/**
 * @fn std::vector<uint8_t> DataCompression::storeAsRawBinary(uint16_t* data, size_t count)
 * 
 * @brief Store data as raw binary with minimal overhead.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param count Number of data points (length of data array).
 * 
 * @return std::vector<uint8_t> Raw binary data as a byte vector.
 */
std::vector<uint8_t> DataCompression::storeAsRawBinary(uint16_t* data, size_t count) 
{
    std::vector<uint8_t> result;
    
    // For small datasets (≤8 values), skip header overhead
    if (count <= 8) 
    {
        result.reserve(count * 2);
        for (size_t i = 0; i < count; i++) 
        {
            result.push_back(data[i] & 0xFF);
            result.push_back((data[i] >> 8) & 0xFF);
        }
        return result;
    }
    
    // For larger datasets, use header
    result.push_back(0x00);  // METHOD_ID
    result.push_back(count); // COUNT
    for (size_t i = 0; i < count; i++) 
    {
        result.push_back(data[i] & 0xFF);
        result.push_back((data[i] >> 8) & 0xFF);
    }
    return result;
}

// ==================== UTILITY FUNCTIONS ====================
/**
 * @fn void DataCompression::packBitsIntoBuffer(uint16_t value, uint8_t* buffer, size_t bitOffset, uint8_t numBits)
 * 
 * @brief Pack a value into a byte buffer at a specific bit offset.
 * 
 * @param value The value to pack (should fit within numBits).
 * @param buffer Pointer to the byte buffer.
 * @param bitOffset Bit offset in the buffer to start packing.
 * @param numBits Number of bits to use for the value.
 */
void DataCompression::packBitsIntoBuffer(uint16_t value, uint8_t* buffer, size_t bitOffset, uint8_t numBits) 
{
    uint16_t mask = (1 << numBits) - 1;
    value &= mask;
    
    size_t byteOffset = bitOffset / 8;
    uint8_t bitPos = bitOffset % 8;
    
    if (bitPos + numBits <= 8) 
    {
        buffer[byteOffset] |= (value << (8 - bitPos - numBits));
    } 
    else 
    {
        uint8_t firstBits = 8 - bitPos;
        uint8_t remainingBits = numBits - firstBits;
        
        buffer[byteOffset] |= (value >> remainingBits);
        buffer[byteOffset + 1] |= ((value & ((1 << remainingBits) - 1)) << (8 - remainingBits));
    }
}

/**
 * @fn DataCompression::DataCharacteristics DataCompression::analyzeData(uint16_t* data, size_t count)
 * 
 * @brief Analyze data characteristics to inform compression strategy.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param count Number of data points (length of data array).
 * 
 * @return DataCharacteristics Struct containing analysis results.
 */
DataCompression::DataCharacteristics DataCompression::analyzeData(uint16_t* data, size_t count) 
{
    DataCharacteristics characteristics = {0};
    
    if (count == 0 || data == nullptr) return characteristics;
    
    uint16_t minVal = data[0], maxVal = data[0];
    uint32_t sum = 0;
    size_t repeatedPairs = 0;
    int32_t totalDeltaMagnitude = 0;
    size_t largeDeltas = 0;
    
    for (size_t i = 0; i < count; i++) 
    {
        if (data[i] < minVal) minVal = data[i];
        if (data[i] > maxVal) maxVal = data[i];
        sum += data[i];
        
        if (i > 0) 
        {
            if (data[i] == data[i-1]) repeatedPairs++;
            
            int32_t delta = abs((int32_t)data[i] - (int32_t)data[i-1]);
            totalDeltaMagnitude += delta;
            
            if (delta > largeDeltaThreshold) largeDeltas++;
        }
    }
    
    characteristics.minValue = minVal;
    characteristics.maxValue = maxVal;
    characteristics.valueRange = maxVal - minVal;
    characteristics.repeatRatio = (count > 1) ? (float)repeatedPairs / (count - 1) : 0.0f;
    characteristics.avgDeltaMagnitude = (count > 1) ? (float)totalDeltaMagnitude / (count - 1) : 0.0f;
    characteristics.largeDeltaRatio = (count > 1) ? (float)largeDeltas / (count - 1) : 0.0f;
    
    // Calculate optimal bits needed
    characteristics.optimalBits = 1;
    while ((1 << characteristics.optimalBits) <= maxVal) 
    {
        characteristics.optimalBits++;
    }
    
    characteristics.suitableForBitPack = (characteristics.optimalBits < 16);
    characteristics.suitableForDelta = (characteristics.avgDeltaMagnitude < 200);
    characteristics.suitableForRLE = (characteristics.repeatRatio > 0.3f);
    
    return characteristics;
}

// ==================== STATISTICS AND REPORTING ====================
/**
 * @fn void DataCompression::printCompressionStats(const char* method, size_t originalSize, size_t compressedSize)
 * 
 * @brief Print detailed compression statistics.
 * 
 * @param method Compression method name.
 * @param originalSize Size of the original uncompressed data in bytes.
 * @param compressedSize Size of the compressed data in bytes.
 */
void DataCompression::printCompressionStats(const char* method, size_t originalSize, size_t compressedSize) 
{
    if (originalSize == 0) 
    {
        print("Error: Original size is zero\n");
        return;
    }
    
    // Calculate both academic and traditional ratios
    float academicRatio = (float)compressedSize / (float)originalSize;
    float traditionalRatio = (float)originalSize / (float)compressedSize;
    float savings = (1.0f - academicRatio) * 100.0f;

    print("COMPRESSION STATISTICS (Academic Format)\n");
    print("Method: %s\n", method);
    print("Original: %zu bytes -> Compressed: %zu bytes\n", originalSize, compressedSize);
    print("Academic Compression Ratio: %.3f (%.1f%% of original)\n", academicRatio, academicRatio * 100);
    print("Traditional Ratio: %.2f:1\n", traditionalRatio);
    print("Storage Savings: %.1f%%\n", savings);
    
    const char* efficiency = (academicRatio < EXCELLENT_RATIO_THRESHOLD) ? "Excellent" :
                           (academicRatio < GOOD_RATIO_THRESHOLD) ? "Good" :
                           (academicRatio < POOR_RATIO_THRESHOLD) ? "Fair" : "Poor";
    print("Efficiency Rating: %s\n", efficiency);
    print("================================\n");
}


/**
 * @fn void DataCompression::printMemoryUsage()
 * 
 * @brief Print current memory usage statistics of the ESP32.
 */
void DataCompression::printMemoryUsage() 
{
    print("ESP32 MEMORY STATUS\n");
    print("Free Heap: %u bytes\n", ESP.getFreeHeap());
    print("Heap Size: %u bytes\n", ESP.getHeapSize());
    print("Max Alloc: %u bytes\n", ESP.getMaxAllocHeap());
    print("PSRAM Free: %u bytes\n", ESP.getFreePsram());
    print("Flash Size: %u bytes\n", ESP.getFlashChipSize());
    print("==========================\n");
}

// ==================== ERROR HANDLING ====================
/**
 * @fn void DataCompression::setError(const String& errorMsg, ErrorType errorType)
 * 
 * @brief Set the last error message and type.
 * 
 * @param errorMsg Error message string.
 * @param errorType Type of error (ERROR_NONE, ERROR_WARNING, ERROR_CRITICAL).
 */
void DataCompression::setError(const String& errorMsg, ErrorType errorType) 
{
    lastErrorMessage = errorMsg;
    lastErrorType = errorType;
    if (debugMode) 
    {
        print("DataCompression Error: %s\n", errorMsg.c_str());
    }
}


/**
 * @fn void DataCompression::getLastError(char* result, size_t resultSize)
 * 
 * @brief Retrieve the last error message.
 * 
 * @param result Buffer to store the error message.
 * @param resultSize Size of the result buffer.
 */
void DataCompression::getLastError(char* result, size_t resultSize) 
{
    strncpy(result, lastErrorMessage.c_str(), resultSize - 1);
    result[resultSize - 1] = '\0';
}


/**
 * @fn void DataCompression::clearError()
 * 
 *  @brief Clear the last error message and type.
 */
void DataCompression::clearError() 
{
    lastErrorMessage = "";
    lastErrorType = ERROR_NONE;
}


/**
 * @fn bool DataCompression::hasError()
 * 
 * @brief Check if there is a current error.
 */
bool DataCompression::hasError() 
{
    return lastErrorType != ERROR_NONE;
}

// ==================== LEGACY COMPATIBILITY ====================
/**
 * @fn void DataCompression::compressRegisterData(uint16_t* data, size_t count, char* result, size_t resultSize)
 * 
 * @brief Compress register data and encode as base64 with prefix.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param count Number of data points (length of data array).
 * @param result Buffer to store the resulting string (base64 encoded).
 * @param resultSize Size of the result buffer.
 */
void DataCompression::compressRegisterData(uint16_t* data, size_t count, char* result, size_t resultSize) 
{
    std::vector<uint8_t> binaryCompressed = compressBinary(data, count);
    
    if (binaryCompressed.empty()) 
    {
        strncpy(result, "ERROR:", resultSize - 1);
        result[resultSize - 1] = '\0';
        return;
    }
    
    // Create BINARY: prefix
    size_t prefixLen = strlen("BINARY:");
    if (prefixLen < resultSize) 
    {
        strcpy(result, "BINARY:");
        base64Encode(binaryCompressed, result + prefixLen, resultSize - prefixLen);
    } 
    else 
    {
        result[0] = '\0';
    }
}


/**
 * @fn void DataCompression::base64Encode(const std::vector<uint8_t>& data, char* result, size_t resultSize)
 * 
 * @brief Encode binary data to base64 string.
 * 
 * @param data Vector of bytes to encode.
 * @param result Buffer to store the resulting base64 string.
 * @param resultSize Size of the result buffer.
 */
void DataCompression::base64Encode(const std::vector<uint8_t>& data, char* result, size_t resultSize) 
{
    const char* chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    size_t pos = 0;
    
    for (size_t i = 0; i < data.size() && pos < resultSize - 5; i += 3) 
    {
        uint32_t value = data[i] << 16;
        if (i + 1 < data.size()) value |= data[i + 1] << 8;
        if (i + 2 < data.size()) value |= data[i + 2];
        
        result[pos++] = chars[(value >> 18) & 0x3F];
        result[pos++] = chars[(value >> 12) & 0x3F];
        result[pos++] = chars[(value >> 6) & 0x3F];
        result[pos++] = chars[value & 0x3F];
    }
    
    while (pos % 4 && pos < resultSize - 1) result[pos++] = '=';
    result[pos] = '\0';
}

// ==================== CONFIGURATION MANAGEMENT IMPLEMENTATIONS ====================
/**
 * @fn void DataCompression::enableDebug(bool enable)
 * 
 * @brief Enable or disable debug mode.
 * 
 * @param enable True to enable debug mode, false to disable.
 */
void DataCompression::setMaxMemoryUsage(size_t maxBytes) 
{
    maxMemoryUsage = maxBytes;
}


/**
 * @fn void DataCompression::enableDebug(bool enable)
 * 
 * @brief Enable or disable debug mode.
 * 
 * @param enable True to enable debug mode, false to disable.
 */
void DataCompression::setCompressionPreference(float preference) 
{
    compressionPreference = constrain(preference, 0.0f, 1.0f);
}

/**
 * @fn void DataCompression::enableDebug(bool enable)
 * 
 * @brief Enable or disable debug mode.
 * 
 * @param enable True to enable debug mode, false to disable.
 */
void DataCompression::setLargeDeltaThreshold(uint16_t threshold) 
{
    largeDeltaThreshold = threshold;
}


/**
 * @fn void DataCompression::enableDebug(bool enable)
 * 
 * @brief Enable or disable debug mode.
 * 
 * @param enable True to enable debug mode, false to disable.
 */
void DataCompression::setBitPackingThreshold(uint8_t minBitsSaved) 
{
    bitPackingThreshold = minBitsSaved;
}


/**
 * @fn void DataCompression::enableDebug(bool enable)
 * 
 * @brief Enable or disable debug mode.
 * 
 * @param enable True to enable debug mode, false to disable.
 */
void DataCompression::setDictionaryLearningRate(float rate) 
{
    dictionaryLearningRate = constrain(rate, 0.0f, 1.0f);
}

// ==================== MISSING REPORTING FUNCTION ====================
/**
 * @fn void DataCompression::printMethodPerformanceStats()
 * 
 * @brief Print performance statistics for all compression methods.
 */
void DataCompression::printMethodPerformanceStats() 
{
    print("\nMETHOD PERFORMANCE STATISTICS\n");
    print("═══════════════════════════════════════\n");
    
    for (const auto& stat : methodStats) 
    {
        if (stat.useCount > 0) {
            print("Method: %s\n", stat.methodName.c_str());
            print("   Uses: %lu times\n", stat.useCount);
            print("   Avg Ratio: %.3f\n", stat.avgCompressionRatio);
            print("   Avg Time: %lu μs\n", stat.avgTimeUs);
            print("   Success Rate: %.1f%%\n", stat.successRate * 100);
            print("   Adaptive Score: %.3f\n", stat.adaptiveScore);
            print("   Total Savings: %lu bytes\n", stat.totalSavings);
            print("   ───────────────────────\n");
        }
    }

    print("═══════════════════════════════════════\n");
}

// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/application/compression_benchmark.cpp =====
#include "application/compression_benchmark.h"


/**
 * @fn BenchmarkResult CompressionBenchmark::testCompression(uint16_t* data, size_t count, const char* method)
 * 
 * @brief Test a specific compression method and return benchmark results.
 * 
 * @param data Pointer to the original data array.
 * @param count Number of samples in the data array.
 * @param method Compression method to test ("DELTA", "RLE", "HYBRID").
 * 
 * @return BenchmarkResult struct containing performance metrics.
 */
BenchmarkResult CompressionBenchmark::testCompression(uint16_t* data, size_t count, const char* method) 
{
    BenchmarkResult result;
    strncpy(result.compressionMethod, method, sizeof(result.compressionMethod) - 1);
    result.compressionMethod[sizeof(result.compressionMethod) - 1] = '\0';
    result.numberOfSamples = count;
    result.originalPayloadSize = count * sizeof(uint16_t);
    
    unsigned long startTime = millis();
    char compressed[256];
    std::vector<uint16_t> decompressed;
    
    if (strcmp(method, "DELTA") == 0) 
    {
        DataCompression::compressRegisterData(data, count, compressed, sizeof(compressed));
        uint16_t tempData[32];
        size_t decompressedCount = DataCompression::decompressRegisterData(compressed, tempData, 32);
        decompressed.clear();
        for (size_t i = 0; i < decompressedCount; i++) 
        {
            decompressed.push_back(tempData[i]);
        }
    } 
    else if (strcmp(method, "RLE") == 0) 
    {
        // Use binary RLE methods and convert to string for compatibility
        std::vector<uint8_t> binaryCompressed = DataCompression::compressBinaryRLE(data, count);
        char base64Buffer[256];
        DataCompression::base64Encode(binaryCompressed, base64Buffer, sizeof(base64Buffer));
        strcpy(compressed, base64Buffer);
        decompressed = DataCompression::decompressBinaryRLE(binaryCompressed);
    } 
    else if (strcmp(method, "HYBRID") == 0) 
    {
        // Use the main binary compression method which selects optimal method
        std::vector<uint8_t> binaryCompressed = DataCompression::compressBinary(data, count);
        char base64Buffer[256];
        DataCompression::base64Encode(binaryCompressed, base64Buffer, sizeof(base64Buffer));
        strcpy(compressed, base64Buffer);
        decompressed = DataCompression::decompressBinary(binaryCompressed);
    }
    
    unsigned long endTime = millis();
    
    result.compressedPayloadSize = strlen(compressed);
    result.compressionRatio = (float)result.originalPayloadSize / (float)result.compressedPayloadSize;
    result.cpuTimeMs = endTime - startTime;
    result.losslessVerified = verifyLosslessRecovery(data, decompressed, count);
    
    return result;
}


/**
 * @fn void CompressionBenchmark::printBenchmarkReport(const BenchmarkResult& result)
 * 
 * @brief Print a formatted benchmark report to the console.
 * 
 * @param result BenchmarkResult struct containing performance metrics.
 */
void CompressionBenchmark::printBenchmarkReport(const BenchmarkResult& result) 
{
    print("=== COMPRESSION BENCHMARK REPORT ===\n");
    print("Compression Method Used: %s\n", result.compressionMethod);
    print("Number of Samples: %lu\n", result.numberOfSamples);
    print("Original Payload Size: %lu bytes\n", result.originalPayloadSize);
    print("Compressed Payload Size: %lu bytes\n", result.compressedPayloadSize);
    print("Compression Ratio: %.2f:1\n", result.compressionRatio);
    print("CPU Time: %lu ms\n", result.cpuTimeMs);
    print("Lossless Recovery Verification: %s\n", result.losslessVerified ? "PASSED" : "FAILED");
    print("Storage Savings: %.1f%%\n", (1.0 - (float)result.compressedPayloadSize / (float)result.originalPayloadSize) * 100.0);
    print("=====================================\n");
}


/**
 * @fn bool CompressionBenchmark::verifyLosslessRecovery(uint16_t* original, const std::vector<uint16_t>& recovered, size_t count)
 * 
 * @brief Verify that the decompressed data matches the original data.
 * 
 * @param original Pointer to the original data array.
 * @param recovered Vector containing the decompressed data.
 * @param count Number of samples to verify.
 * 
 * @return true if data matches, false otherwise.
 */
bool CompressionBenchmark::verifyLosslessRecovery(uint16_t* original, const std::vector<uint16_t>& recovered, size_t count) 
{
    if (recovered.size() != count) return false;
    
    for (size_t i = 0; i < count; i++) 
    {
        if (original[i] != recovered[i]) return false;
    }
    return true;
}

// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/application/nvs.cpp =====
#include "application/nvs.h"

// Global NVS instance definition
Preferences esp_prefs_nvs;

nvs::nvs() {}

uint8_t nvs::getReadRegCount()
{
    if (!esp_prefs_nvs.isKey("reg_count"))
    {
        return 6;
    }
    else
    {
        esp_prefs_nvs.begin("readregs", true); // Open NVS in read-only mode
        uint8_t stored_count = esp_prefs_nvs.getInt("reg_count", 0);
        esp_prefs_nvs.end();
        return stored_count;
    }
}

const RegID* nvs::getReadRegs()
{
    static RegID defaultRegs[] = {REG_VAC1, REG_IAC1, REG_IPV1, REG_PAC, REG_IPV2, REG_TEMP};

    if (!esp_prefs_nvs.isKey("read_regs"))
    {
        esp_prefs_nvs.begin("readregs", false); // Open NVS in read-write mode

        size_t bytes_to_write = sizeof(defaultRegs);
        esp_prefs_nvs.putInt("reg_count", sizeof(defaultRegs) / sizeof(defaultRegs[0]));
        size_t bytes_written = esp_prefs_nvs.putBytes("read_regs", defaultRegs, bytes_to_write);

        esp_prefs_nvs.end();
        
        return defaultRegs;
    }
    else
    {
        esp_prefs_nvs.begin("readregs", true); // Open NVS in read-only mode

        size_t stored_count = esp_prefs_nvs.getInt("reg_count", 0);
        static RegID* stored_regs = nullptr;
        
        // Clean up previous allocation
        if (stored_regs != nullptr) {
            delete[] stored_regs;
        }
        
        stored_regs = new RegID[stored_count];
        size_t bytes_read = esp_prefs_nvs.getBytes("read_regs", stored_regs, stored_count * sizeof(RegID));
        esp_prefs_nvs.end();

        if (bytes_read == stored_count * sizeof(RegID))
        {
            return stored_regs;
        }
        else
        {
            return defaultRegs;
        }
    }
}


uint64_t nvs::getPollFreq()
{
    uint64_t defaultPollFreq = 2000000;   // 2 seconds

    if (!esp_prefs_nvs.isKey("poll_freq"))
    {
        esp_prefs_nvs.begin("freq", false); // Open NVS in read-write mode

        esp_prefs_nvs.putULong64("poll_freq", defaultPollFreq);
        esp_prefs_nvs.end();

        return defaultPollFreq;
    }
    else
    {
        esp_prefs_nvs.begin("freq", true); // Open NVS in read-only mode

        uint64_t stored_freq = esp_prefs_nvs.getULong64("poll_freq", defaultPollFreq);
        esp_prefs_nvs.end();

        if (stored_freq > MIN_POLL_FREQ) // Minimum 100ms
        {
            return stored_freq;
        }
        else
        {
            return defaultPollFreq;
        }        
    }
}


uint64_t nvs::getUploadFreq()
{
    uint64_t defaultUploadFreq = 15000000;   // 15 seconds

    if (!esp_prefs_nvs.isKey("upload_freq"))
    {
        esp_prefs_nvs.begin("freq", false); // Open NVS in read-write mode

        esp_prefs_nvs.putULong64("upload_freq", defaultUploadFreq);
        esp_prefs_nvs.end();

        return defaultUploadFreq;
    }
    else
    {
        esp_prefs_nvs.begin("freq", true); // Open NVS in read-only mode

        uint64_t stored_freq = esp_prefs_nvs.getULong64("upload_freq", defaultUploadFreq);
        esp_prefs_nvs.end();

        if (stored_freq > MIN_UPLOAD_FREQ) // Minimum 1 second
        {
            return stored_freq;
        }
        else
        {
            return defaultUploadFreq;
        }
    }
}


bool nvs::saveReadRegs(const RegID* selection, size_t count) 
{
    if (selection == nullptr || count == 0) 
    {
        return false; // Invalid input
    }

    for (size_t i = 0; i < count; i++) 
    {
        if (selection[i] >= REG_MAX) 
        {
            return false; // Invalid RegID
        }
    }

    if (!esp_prefs_nvs.begin("readregs", false)) // Open NVS in read-write mode
    {
        return false; // Failed to open NVS
    }

    size_t bytes_to_write = count * sizeof(RegID);
    size_t bytes_written = esp_prefs_nvs.putBytes("read_regs", selection, bytes_to_write);
    esp_prefs_nvs.end();

    if (bytes_to_write != bytes_written)
    {
        return false;
    }

    return true;
}

bool nvs::changePollFreq(uint64_t poll_time)
{
    if (poll_time == 0) 
    {
        return false; // Invalid input
    }

    if (!esp_prefs_nvs.begin("freq", false)) // Open NVS in read-write mode
    {
        return false; // Failed to open NVS
    }

    size_t bytes_written = esp_prefs_nvs.putULong64("poll_freq", poll_time);
    esp_prefs_nvs.end();

    if (bytes_written != sizeof(uint64_t))
    {
        return false;
    }

    return true;
}


bool nvs::changeUploadFreq(uint64_t upload_time)
{
    if (upload_time == 0) 
    {
        return false; // Invalid input
    }

    if (!esp_prefs_nvs.begin("freq", false)) // Open NVS in read-write mode
    {
        return false; // Failed to open NVS
    }

    size_t bytes_written = esp_prefs_nvs.putULong64("upload_freq", upload_time);
    esp_prefs_nvs.end();

    if (bytes_written != sizeof(uint64_t))
    {
        return false;
    }

    return true;
}


// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/driver/debug.cpp =====
#include "driver/debug.h"

// Define the single shared instance declared in the header
Debug debug;

Debug::Debug() {}

/**
 * @fn void Debug::init()
 * 
 * @brief Initialize the debug serial interface.
 */
void Debug::init()
{
    Serial.begin(115200);
}


/**
 * @fn void Debug::log(const char *format, ...)
 * 
 * @brief Log a formatted debug message to the serial console.
 * 
 * @param format printf-style format string.
 * @param ... Additional arguments for formatting.
 */
void Debug::log(const char *format, ...) 
{
    char buffer[DEBUG_BUFFER_SIZE];

    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    Serial.print(buffer);
}

// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/driver/delay.cpp =====
#include "driver/delay.h"

// Define the single shared instance declared in the header
Delay wait;

/**
 * @fn void Delay::ms(unsigned long ms)
 * 
 * @brief Delay execution for a specified number of milliseconds.
 * 
 * @param ms Number of milliseconds to delay.
 */
void Delay::ms(unsigned long ms)
{
  ::delay(ms);
}

// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/driver/protocol_adapter.cpp =====

#include <ArduinoJson.h>
#include <Arduino.h>
#include "driver/protocol_adapter.h"

ProtocolAdapter::ProtocolAdapter() {}

/**
 * @fn bool ProtocolAdapter::writeRegister(const char* frameHex, char* outFrameHex, size_t outSize)
 * 
 * @brief Write a register value to the device.
 * 
 * @param frameHex Hexadecimal frame data to send.
 * @param outFrameHex Buffer to store the response frame.
 * @param outSize Size of the response buffer.
 * @return true if successful, false otherwise.
 */
bool ProtocolAdapter::writeRegister(const char* frameHex, char* outFrameHex, size_t outSize)
{
  char responseJson[256];
  bool state = sendRequest(writeURL, frameHex, responseJson, sizeof(responseJson));
  if (!state) return false;

  state = parseResponse(responseJson, outFrameHex, outSize);
  if (!state)
  {
    debug.log("Write operation failed. Then Retry\n");
    int retry = 1;
    while (retry <= 3 && !state)
    {
      debug.log("Retry attempt %d\n", retry);
      state = sendRequest(writeURL, frameHex, responseJson, sizeof(responseJson));
      if (state)
      {
        state = parseResponse(responseJson, outFrameHex, outSize);
      }
      if (!state)
      {
        retry++;
      }
      else
      {
        debug.log("Write operation successful on retry\n");
        break;
      }
    }
  }
  return state;
}


/** 
 * @fn bool ProtocolAdapter::readRegister(const char* frameHex, char* outFrameHex, size_t outSize)
 * 
 * @brief Read a register value from the device.
 * 
 * @param frameHex Hexadecimal frame data to send.
 * @param outFrameHex Buffer to store the response frame.
 * @param outSize Size of the response buffer.
 * @return true if successful, false otherwise.
 */
bool ProtocolAdapter::readRegister(const char* frameHex, char* outFrameHex, size_t outSize)
{
  char responseJson[1024];
  bool state = sendRequest(readURL, frameHex, responseJson, sizeof(responseJson));
  if (!state) return false;

  state = parseResponse(responseJson, outFrameHex, outSize);
  if (!state)
  {
    debug.log("Read operation failed. Then Retry\n");
    int retry = 1;
    while (retry <= 3 && !state)
    {
      debug.log("Retry attempt %d\n", retry);
      state = sendRequest(readURL, frameHex, responseJson, sizeof(responseJson));
      if (state)
      {
        state = parseResponse(responseJson, outFrameHex, outSize);
      }
      if (!state)
      {
        retry++;
      }
      else
      {
        debug.log("Read operation successful on retry\n");
        break;
      }
    }
  }
  return state;
}

//  Robust Send with Retry
/**
 * @fn bool ProtocolAdapter::sendRequest(const char* url, const char* frameHex, char* outResponseJson, size_t outSize)
 * 
 * @brief Send a JSON request to the specified URL with retry logic.
 * 
 * @param url The URL to send the request to.
 * @param frameHex The hexadecimal frame data to include in the request.
 * @param outResponseJson Buffer to store the JSON response.
 * @param outSize Size of the response buffer.
 * @return true if the request was successful, false otherwise.
 */
bool ProtocolAdapter::sendRequest(const char* url, const char* frameHex, char* outResponseJson, size_t outSize)
{
  HTTPClient http;
  int attempt = 0;
  int backoffDelay = 500; // ms

  while (attempt < maxRetries)
  {
    attempt++;
    if (!http.begin(url)) 
    {
      debug.log("HTTP begin failed\n");
      return false;
    }
    http.setTimeout(httpTimeout);
    http.addHeader("Content-Type", "application/json");
    http.addHeader("accept", "*/*");
    http.addHeader("Authorization", apiKey);

    char payload[256];
    snprintf(payload, sizeof(payload), "{\"frame\": \"%s\"}", frameHex);
    debug.log("Attempt %d: Sending %s\n", attempt, payload);

    // Use String for HTTP POST, but only for the call
    String payloadStr(payload);
    int httpResponseCode = http.POST((uint8_t*)payloadStr.c_str(), payloadStr.length());
    bool ok = false;
    if (httpResponseCode > 0) 
    {
      debug.log("Response code: %d\n", httpResponseCode);
      String response = http.getString();
      debug.log("HTTP response: %s\n", response.c_str());
      // Convert String response to char array
      if (outResponseJson && outSize > 0) {
        size_t copyLen = (response.length() < (outSize-1)) ? response.length() : (outSize-1);
        memcpy(outResponseJson, response.c_str(), copyLen);
        outResponseJson[copyLen] = '\0';
      }
      ok = (response.length() > 0);
      if (!ok) 
      {
        debug.log("Empty response, retrying...\n");
      } 
      else 
      {
        http.end();
        return true;
      }
    } 
    else 
    {
      debug.log("Request failed (code %d), retrying...\n", httpResponseCode);
    }

    http.end();
    debug.log("Waiting %d ms before retry...\n", backoffDelay);
    wait.ms(backoffDelay);
    backoffDelay *= 2;
  }

  debug.log("Failed after max retries.\n");
  return false;
}

//  Parse & Error Handling
/**
 * @fn bool ProtocolAdapter::parseResponse(const char* response, char* outFrameHex, size_t outSize)
 * 
 * @brief Parse the JSON response from the device.
 * 
 * @param response The JSON response string.
 * @param outFrameHex Buffer to store the extracted frame data.
 * @param outSize Size of the output buffer.
 * @return true if parsing was successful, false otherwise.
 */
bool ProtocolAdapter::parseResponse(const char* response, char* outFrameHex, size_t outSize) 
{

  size_t resp_len = response ? strlen(response) : 0;
  debug.log("Raw HTTP response: %s\n", response ? response : "(null)");
  debug.log("HTTP response length: %u\n", (unsigned)resp_len);
  debug.log("HTTP response hex: ");
  for (size_t i = 0; i < resp_len && i < 32; ++i) {
    debug.log("%02X ", (unsigned char)response[i]);
  }
  debug.log("\n");
  if (!response || response[0] == '\0') 
  {
    debug.log("No response.\n");
    return false;
  }

  StaticJsonDocument<256> doc;
  DeserializationError err = deserializeJson(doc, response);
  if (err) {
    debug.log("JSON parse failed\n");
    return false;
  }
  const char* frame = doc["frame"] | "";
  size_t len = strlen(frame);
  if (len + 1 > outSize) {
    debug.log("Frame too large for buffer\n");
    return false;
  }
  memcpy(outFrameHex, frame, len + 1);
  debug.log("Received frame: %s\n", frame);

  // Modbus function code check
  if (len < 6) return false;
  char buf[3]; buf[2] = '\0';
  memcpy(buf, frame + 2, 2);
  int funcCode = (int)strtol(buf, NULL, 16);
  if (funcCode & 0x80) {
    memcpy(buf, frame + 4, 2);
    int errorCode = (int)strtol(buf, NULL, 16);
    debug.log("Modbus Exception: ");
    printErrorCode(errorCode);
    return false;
  } else {
    debug.log("Valid Modbus frame.\n");
    return true;
  }
}

//  Frame Validation
/** 
 * @fn bool ProtocolAdapter::isFrameValid(const char* frame)
 * 
 * @brief Check if the given frame is valid.
 * 
 * @param frame The frame to check.
 * 
 * @return true if valid, false otherwise.
 */
bool ProtocolAdapter::isFrameValid(const char* frame) 
{
  if (!frame) return false;
  size_t len = strlen(frame);
  if (len < 6) return false;
  for (size_t i = 0; i < len; i++) 
  {
    char c = frame[i];
    if (!isxdigit(c)) return false;
  }
  return true;
}

//  Error Printer 
/**
 * @fn void ProtocolAdapter::printErrorCode(int code)
 * 
 * @brief Print a human-readable Modbus error message.
 * 
 * @param code The Modbus error code.
 */
void ProtocolAdapter::printErrorCode(int code) 
{
  switch (code) 
  {
    case 0x01: debug.log("01 - Illegal Function\n"); break;
    case 0x02: debug.log("02 - Illegal Data Address\n"); break;
    case 0x03: debug.log("03 - Illegal Data Value\n"); break;
    case 0x04: debug.log("04 - Slave Device Failure\n"); break;
    case 0x05: debug.log("05 - Acknowledge (processing delayed)\n"); break;
    case 0x06: debug.log("06 - Slave Device Busy\n"); break;
    case 0x08: debug.log("08 - Memory Parity Error\n"); break;
    case 0x0A: debug.log("0A - Gateway Path Unavailable\n"); break;
    case 0x0B: debug.log("0B - Gateway Target Device Failed to Respond\n"); break;
    default:   debug.log("Unknown error code\n"); break;
  }
}


/**
 * @fn void ProtocolAdapter::setApiKey(const char* newApiKey)
 * 
 * @brief Set a new API key for authentication.
 * 
 * @param newApiKey The new API key string.
 */
void ProtocolAdapter::setApiKey(const char* newApiKey)
{
  if (!newApiKey) { apiKey[0] = '\0'; return; }
  strncpy(apiKey, newApiKey, sizeof(apiKey) - 1);
  apiKey[sizeof(apiKey) - 1] = '\0';
}

//  Getters 
/** 
 * @fn const char* ProtocolAdapter::getApiKey()
 * 
 * @brief Get the current API key.
 * 
 * @return The API key string.
 */
const char* ProtocolAdapter::getApiKey() 
{ 
  return apiKey; 
}

// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/main.cpp =====
#include <Arduino.h>
#include "peripheral/acquisition.h"
#include "peripheral/print.h"
#include "peripheral/arduino_wifi.h"
#include "application/ringbuffer.h"
#include "application/compression.h"
#include "application/compression_benchmark.h"
#include "application/nvs.h"

Arduino_Wifi Wifi;
RingBuffer<SmartCompressedData, 20> smartRingBuffer;

const char* dataPostURL = "http://10.243.4.129:5001/process";     // Your PC's actual IP address
const char* fetchChangesURL = "http://10.243.4.129:5001/changes";  // Your PC's actual IP address

void Wifi_init();
void poll_and_save(const RegID* selection, size_t registerCount, uint16_t* sensorData);
void upload_data();
std::vector<uint8_t> compressWithSmartSelection(uint16_t* data, const RegID* selection, size_t count, 
                                               unsigned long& compressionTime, char* methodUsed, size_t methodSize,
                                               float& academicRatio, float& traditionalRatio);
void printSmartPerformanceStatistics();
void uploadSmartCompressedDataToCloud();
std::vector<uint8_t> compressBatchWithSmartSelection(const SampleBatch& batch, 
                                                   unsigned long& compressionTime, 
                                                   char* methodUsed, size_t methodSize,
                                                   float& academicRatio, 
                                                   float& traditionalRatio);
void convertBinaryToBase64(const std::vector<uint8_t>& binaryData, char* result, size_t resultSize);
void updateSmartPerformanceStatistics(const char* method, float academicRatio, unsigned long timeUs);
bool readMultipleRegisters(const RegID* selection, size_t count, uint16_t* data);
void enhanceDictionaryForOptimalCompression();
void checkChanges(bool* registers_uptodate, bool* pollFreq_uptodate, bool* uploadFreq_uptodate);

hw_timer_t *poll_timer = NULL;
volatile bool poll_token = false;

SmartPerformanceStats smartStats;
SampleBatch currentBatch;

void IRAM_ATTR set_poll_token() 
{
  poll_token = true;
}

hw_timer_t *upload_timer = NULL;
volatile bool upload_token = false;

void IRAM_ATTR set_upload_token() 
{
  upload_token = true;
}

hw_timer_t *changes_timer = NULL;
volatile bool changes_token = false;

void IRAM_ATTR set_changes_token() 
{
  changes_token = true;
}

// Define registers to read
// const RegID selection[] = {REG_VAC1, REG_IAC1, REG_IPV1, REG_PAC, REG_IPV2, REG_TEMP};

void setup() 
{
  print_init();
  print("Starting ECOWATT\n");

  Wifi_init();

  // Reading values from the nvs
  size_t registerCount = nvs::getReadRegCount();
  const RegID* selection = nvs::getReadRegs();
  bool registers_uptodate = true;
  uint16_t* sensorData = nullptr;
  sensorData = new uint16_t[registerCount];

  uint64_t pollFreq = nvs::getPollFreq();
  bool pollFreq_uptodate = true;

  uint64_t uploadFreq = nvs::getUploadFreq();
  bool uploadFreq_uptodate = true;
  
  uint64_t checkChangesFreq = 5000000;
  
  // Set up the poll timer
  poll_timer = timerBegin(0, 80, true); // Timer 0, prescaler 80 (1us per tick)
  timerAttachInterrupt(poll_timer, &set_poll_token, true);
  timerAlarmWrite(poll_timer, pollFreq, true);
  timerAlarmEnable(poll_timer); // Enable the alarm

  // Set up the upload timer
  upload_timer = timerBegin(1, 80, true); // Timer 1, prescaler 80 (1us per tick)
  timerAttachInterrupt(upload_timer,  &set_upload_token, true);
  timerAlarmWrite(upload_timer, uploadFreq, true);
  timerAlarmEnable(upload_timer); // Enable the alarm

  // Set up the changes check timer
  changes_timer = timerBegin(2, 80, true); // Timer 2, prescaler 80 (1us per tick)
  timerAttachInterrupt(changes_timer,  &set_changes_token, true);
  timerAlarmWrite(changes_timer, checkChangesFreq, true);
  timerAlarmEnable(changes_timer); // Enable the alarm


  enhanceDictionaryForOptimalCompression();
  // Print initial memory status
  DataCompression::printMemoryUsage();

/*
  //set power to 50W out
  bool ok = setPower(50); // set Pac = 50W
  if (ok) 
  {
    print("Output power register updated!\n");
  }
  else 
  {
    print("Failed to set output power register!\n");
  }*/


  while(true) 
  {
    if (poll_token) 
    {
      poll_token = false;
      poll_and_save(selection, registerCount, sensorData);
    }
    
    if (upload_token) 
    {
      upload_token = false;
      upload_data();

      // Applying the changes
      if (!pollFreq_uptodate)
      {
        pollFreq = nvs::getPollFreq();
        timerAlarmWrite(poll_timer, pollFreq, true);
        pollFreq_uptodate = true;
      }

      if (!uploadFreq_uptodate)
      {
        uploadFreq = nvs::getUploadFreq();
        timerAlarmWrite(upload_timer, uploadFreq, true);
        uploadFreq_uptodate = true;
      }

      if (!registers_uptodate)
      {
        delete[] sensorData;
        registerCount = nvs::getReadRegCount();
        const RegID* selection = nvs::getReadRegs();
        sensorData = new uint16_t[registerCount];
        registers_uptodate = true;
      }
    }

    if (changes_token)
    {
        changes_token = false;
        checkChanges(&registers_uptodate, &pollFreq_uptodate, &uploadFreq_uptodate);
    }
  }
}

void loop() {}


void checkChanges(bool *registers_uptodate, bool *pollFreq_uptodate, bool *uploadFreq_uptodate)
{
    print("Checking for changes from cloud...\n");
    if (WiFi.status() != WL_CONNECTED) {
        print("WiFi not connected. Cannot check changes.\n");
        return;
    }

    HTTPClient http;
    http.begin(fetchChangesURL);

    http.addHeader("Content-Type", "application/json");

    StaticJsonDocument<128> changesRequestBody;
    changesRequestBody["device_id"] = "ESP32_EcoWatt_Smart";
    changesRequestBody["timestamp"] = millis();

    char requestBody[128];
    serializeJson(changesRequestBody, requestBody, sizeof(requestBody));

    int httpResponseCode = http.POST((uint8_t*)requestBody, strlen(requestBody));

    if (httpResponseCode > 0) {
        print("HTTP Response code: %d\n", httpResponseCode);

        // Get response into a char buffer
        WiFiClient* stream = http.getStreamPtr();
        static char responseBuffer[1024]; // adjust if your response is larger
        int len = http.getSize();
        int index = 0;

        while (http.connected() && (len > 0 || len == -1)) 
        {
            if (stream->available()) 
            {
                char c = stream->read();
                if (index < (int)sizeof(responseBuffer) - 1)
                responseBuffer[index++] = c;
                if (len > 0) len--;
            }
        }
        responseBuffer[index] = '\0'; // null terminate
        print("ChangedResponse:");
        print(responseBuffer);

        StaticJsonDocument<1024> responsedoc;

        DeserializationError error = deserializeJson(responsedoc, responseBuffer);
        
        if (!error)
        {
            bool settingsChanged = responsedoc["Changed"] | false;
            
            if (settingsChanged)
            {
                bool pollFreqChanged = responsedoc["pollFreqChanged"] | false;
                if (pollFreqChanged)
                {
                    uint64_t new_poll_timer = responsedoc["newPollTimer"] | 0;
                    nvs::changePollFreq(new_poll_timer);
                    *pollFreq_uptodate = false;
                    print("Poll timer set to update in next cycle\n");
                }

                bool uploadFreqChanged = responsedoc["uploadFreqChanged"] | false;
                if (uploadFreqChanged)
                {
                    uint64_t new_upload_timer = responsedoc["newUploadTimer"] | 0;
                    nvs::changeUploadFreq(new_upload_timer);
                    *uploadFreq_uptodate = false;
                    print("Upload timer set to update in next cycle\n");
                }

                bool regsChanged = responsedoc["regsChanged"] | false;
                if (regsChanged)
                {
                    size_t regsCount = responsedoc["regsCount"] | 0;

                    if (regsCount > 0 && responsedoc.containsKey("regs"))
                    {
                        JsonArray regsArray = responsedoc["regs"].as<JsonArray>();

                        RegID* newRegs = new RegID[regsCount];
                        size_t validCount = 0;

                        for (size_t i = 0; i < regsCount; i++) 
                        {
                            const char* regName = regsArray[i] | "";

                            for (size_t j = 0; j < REGISTER_COUNT; j++) 
                            {
                                if (strcmp(REGISTER_MAP[j].name, regName) == 0) 
                                {
                                    newRegs[validCount++] = REGISTER_MAP[j].id;
                                    break;
                                }
                            }
                        }

                        if (validCount > 0) {
                            // Store in NVS
                            nvs::saveReadRegs(newRegs, validCount);
                            *registers_uptodate = false;
                            print("Set to update %d registers in next cycle.\n", validCount);               
                        }

                        delete[] newRegs;
                    }
                }
            }

            print("Changes noted\n");
            http.end();
        }
        else
        {
            http.end();
            print("Settings change error\n");
        }
    }
}

/**
 * @fn void Wifi_init()
 * 
 * @brief Function to initialise Wifi
 */
void Wifi_init()
{
  Wifi.setSSID("YasithsRedmi");
  Wifi.setPassword("xnbr2615");
  Wifi.begin();
}


/**
 * @fn void poll_and_save()
 * 
 * @brief Poll sensor data, compress with smart selection, and save to ring buffer.
 */
void poll_and_save(const RegID* selection, size_t registerCount, uint16_t* sensorData)
{
  if (readMultipleRegisters(selection, registerCount, sensorData)) 
  {
    // Process the read sensor data
    // Add to batch
    currentBatch.addSample(sensorData, millis());

    // When batch is full, compress and store
    if (currentBatch.isFull()) {
        unsigned long compressionTime;
        char methodUsed[32];
        float academicRatio, traditionalRatio;
        
        // Compress the entire batch with smart selection
        std::vector<uint8_t> compressedBinary = compressBatchWithSmartSelection(
            currentBatch, compressionTime, methodUsed, sizeof(methodUsed), academicRatio, traditionalRatio);
        
        // Store compressed data with metadata
        if (!compressedBinary.empty()) {
            SmartCompressedData entry(compressedBinary, selection, registerCount, methodUsed);
            entry.compressionTime = compressionTime;
            entry.academicRatio = academicRatio;
            entry.traditionalRatio = traditionalRatio;
            entry.losslessVerified = true;
            
            smartRingBuffer.push(entry);
            
            // Update global statistics
            smartStats.totalOriginalBytes += entry.originalSize;
            smartStats.totalCompressedBytes += compressedBinary.size();
            
            print("Batch compressed and stored successfully!\n");
        } else {
            print("Compression failed for batch!\n");
            smartStats.compressionFailures++;
        }
        
        // Reset batch for next collection
        currentBatch.reset();
    }
  }
  else
  {
    print("Failed to read registers\n");
  }
}


/**
 * @fn void upload_data()
 * 
 * @brief Upload all smart compressed data in the ring buffer to the cloud server.
 */
void upload_data()
{
    uploadSmartCompressedDataToCloud();
    printSmartPerformanceStatistics();
}


/**
 * @fn std::vector<uint8_t> compressWithSmartSelection(uint16_t* data, const RegID* selection, size_t count,
 *                                               unsigned long& compressionTime, char* methodUsed, size_t methodSize,
 *                                               float& academicRatio, float& traditionalRatio)
 * 
 * @brief Compress sensor data using the adaptive smart selection system and track performance.
 * 
 * @param data Pointer to the array of uint16_t sensor data.
 * @param selection Pointer to the array of RegID indicating which registers are included.
 * @param count Number of data points (length of data and selection arrays).
 * @param compressionTime Reference to store the time taken for compression (in microseconds).
 * @param methodUsed Pointer to char array to store the name of the compression method used.
 * @param methodSize Size of the methodUsed char array.
 * @param academicRatio Reference to store the academic compression ratio (compressed/original).
 * @param traditionalRatio Reference to store the traditional compression ratio (original/compressed).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> compressWithSmartSelection(uint16_t* data, const RegID* selection, size_t count, 
                                               unsigned long& compressionTime, char* methodUsed, size_t methodSize,
                                               float& academicRatio, float& traditionalRatio) {
    unsigned long startTime = micros();
    
    // Use the advanced smart selection system
    std::vector<uint8_t> compressed = DataCompression::compressWithSmartSelection(data, selection, count);
    
    compressionTime = micros() - startTime;
    
    // Determine method from compressed data header
    if (!compressed.empty()) {
        switch (compressed[0]) {
            case 0xD0: 
                strncpy(methodUsed, "DICTIONARY", methodSize - 1);
                smartStats.dictionaryUsed++;
                break;
            case 0x70:
            case 0x71: 
                strncpy(methodUsed, "TEMPORAL", methodSize - 1);
                smartStats.temporalUsed++;
                break;
            case 0x50: 
                strncpy(methodUsed, "SEMANTIC", methodSize - 1);
                smartStats.semanticUsed++;
                break;
            case 0x01:
            default:
                strncpy(methodUsed, "BITPACK", methodSize - 1);
                smartStats.bitpackUsed++;
        }
        methodUsed[methodSize - 1] = '\0';
    } else {
        strncpy(methodUsed, "ERROR", methodSize - 1);
        methodUsed[methodSize - 1] = '\0';
        smartStats.compressionFailures++;
    }
    
    // Calculate ratios
    size_t originalSize = count * sizeof(uint16_t);
    size_t compressedSize = compressed.size();
    
    academicRatio = (compressedSize > 0) ? (float)compressedSize / (float)originalSize : 1.0f;
    traditionalRatio = (compressedSize > 0) ? (float)originalSize / (float)compressedSize : 0.0f;
    
    // Update performance tracking
    updateSmartPerformanceStatistics(methodUsed, academicRatio, compressionTime);
    
    return compressed;
}


/**
 * @fn updateSmartPerformanceStatistics(const char* method, float academicRatio, unsigned long timeUs)
 * 
 * @brief Update global statistics for smart compression performance tracking.
 * 
 * @param method Name of the compression method used.
 * @param academicRatio Academic compression ratio (compressed/original).
 * @param timeUs Time taken for compression in microseconds.
 */
void updateSmartPerformanceStatistics(const char* method, float academicRatio, 
                                     unsigned long timeUs) {
    smartStats.totalSmartCompressions++;
    smartStats.totalCompressionTime += timeUs;
    smartStats.averageAcademicRatio = 
        (smartStats.averageAcademicRatio * (smartStats.totalSmartCompressions - 1) + academicRatio) / 
        smartStats.totalSmartCompressions;
    
    // Update best ratio if this is better
    if (academicRatio < smartStats.bestAcademicRatio) {
        smartStats.bestAcademicRatio = academicRatio;
        strncpy(smartStats.currentOptimalMethod, method, sizeof(smartStats.currentOptimalMethod) - 1);
        smartStats.currentOptimalMethod[sizeof(smartStats.currentOptimalMethod) - 1] = '\0';
    }
    
    // Update quality distribution
    if (academicRatio <= 0.5f) {
        smartStats.excellentCompressionCount++;
    } else if (academicRatio <= 0.67f) {
        smartStats.goodCompressionCount++;
    } else if (academicRatio <= 0.91f) {
        smartStats.fairCompressionCount++;
    } else {
        smartStats.poorCompressionCount++;
    }
    
    // Update fastest compression time
    if (timeUs < smartStats.fastestCompressionTime) {
        smartStats.fastestCompressionTime = timeUs;
    }
}


/**
 * @fn void enhanceDictionaryForOptimalCompression()
 * 
 * @brief Enhance the dictionary with patterns learned from actual sensor data to improve compression.
 */
void enhanceDictionaryForOptimalCompression() {
    // Add patterns specifically learned from actual sensor data
    // Pattern 0: Your typical readings
    uint16_t pattern0[] = {2429, 177, 73, 4331, 70, 605};
    
    // Pattern 1: Slight variations (±5%)
    uint16_t pattern1[] = {2308, 168, 69, 4115, 67, 575};
    uint16_t pattern2[] = {2550, 186, 77, 4547, 74, 635};
    
    // Pattern 3: Different load conditions
    uint16_t pattern3[] = {2380, 150, 65, 3800, 55, 590};
    uint16_t pattern4[] = {2480, 195, 80, 4800, 85, 620};
}


/**
 * @fn void printSmartPerformanceStatistics()
 * 
 * @brief Print a summary of smart compression performance statistics.
 */
void printSmartPerformanceStatistics() {
    print("\nSMART COMPRESSION PERFORMANCE SUMMARY\n");
    print("=====================================\n");
    print("Total Compressions: %lu\n", smartStats.totalSmartCompressions);
    print("Average Academic Ratio: %.3f\n", smartStats.averageAcademicRatio);
    print("Best Ratio Achieved: %.3f\n", smartStats.bestAcademicRatio);
    print("Optimal Method: %s\n", smartStats.currentOptimalMethod);
    print("Average Time: %lu μs\n", 
          smartStats.totalSmartCompressions > 0 ? 
          smartStats.totalCompressionTime / smartStats.totalSmartCompressions : 0);
    
    print("\nQuality Distribution:\n");
    print("  Excellent (≤50%%): %lu\n", smartStats.excellentCompressionCount);
    print("  Good (≤67%%): %lu\n", smartStats.goodCompressionCount);
    print("  Fair (≤91%%): %lu\n", smartStats.fairCompressionCount);
    print("  Poor (>91%%): %lu\n", smartStats.poorCompressionCount);
    
    print("\nMethod Usage:\n");
    print("  Dictionary: %lu\n", smartStats.dictionaryUsed);
    print("  Temporal: %lu\n", smartStats.temporalUsed);
    print("  Semantic: %lu\n", smartStats.semanticUsed);
    print("  BitPack: %lu\n", smartStats.bitpackUsed);
    print("=====================================\n");
}


/**
 * @fn void uploadSmartCompressedDataToCloud()
 * 
 * @brief Upload all smart compressed data in the ring buffer to the cloud server.
 */
void uploadSmartCompressedDataToCloud() {
    if (WiFi.status() != WL_CONNECTED) {
        print("WiFi not connected. Cannot upload.\n");
        return;
    }

    if (smartRingBuffer.empty()) {
        print("Buffer empty. Nothing to upload.\n");
        return;
    }

    HTTPClient http;
    http.begin(dataPostURL);
    http.addHeader("Content-Type", "application/json");
    
    // New JSON structure with compressed data and decompression metadata
    JsonDocument doc;
    auto allData = smartRingBuffer.drain_all();
    
    doc["device_id"] = "ESP32_EcoWatt_Smart";
    doc["timestamp"] = millis();
    doc["data_type"] = "compressed_sensor_batch";
    doc["total_samples"] = allData.size();
    
    // Register mapping for decompression
    JsonObject registerMapping = doc["register_mapping"].to<JsonObject>();
    registerMapping["0"] = "REG_VAC1";
    registerMapping["1"] = "REG_IAC1";
    registerMapping["2"] = "REG_IPV1";
    registerMapping["3"] = "REG_PAC";
    registerMapping["4"] = "REG_IPV2";
    registerMapping["5"] = "REG_TEMP";
    
    // Compressed data packets with decompression metadata
    JsonArray compressedPackets = doc["compressed_data"].to<JsonArray>();
    
    size_t totalOriginalBytes = 0;
    size_t totalCompressedBytes = 0;
    
    for (const auto& entry : allData) {
        JsonObject packet = compressedPackets.add<JsonObject>();
        
        // Compressed binary data (Base64 encoded)
        char base64Buffer[256];
        convertBinaryToBase64(entry.binaryData, base64Buffer, sizeof(base64Buffer));
        packet["compressed_binary"] = base64Buffer;
        
        // Decompression metadata
        JsonObject decompMeta = packet["decompression_metadata"].to<JsonObject>();
        decompMeta["method"] = entry.compressionMethod;
        decompMeta["register_count"] = entry.registerCount;
        decompMeta["original_size_bytes"] = entry.originalSize;
        decompMeta["compressed_size_bytes"] = entry.binaryData.size();
        decompMeta["timestamp"] = entry.timestamp;
        
        // Register layout for this packet
        JsonArray regLayout = decompMeta["register_layout"].to<JsonArray>();
        for (size_t i = 0; i < entry.registerCount; i++) {
            regLayout.add(entry.registers[i]);
        }
        
        // Compression performance metrics
        JsonObject metrics = packet["performance_metrics"].to<JsonObject>();
        metrics["academic_ratio"] = entry.academicRatio;
        metrics["traditional_ratio"] = entry.traditionalRatio;
        metrics["compression_time_us"] = entry.compressionTime;
        metrics["savings_percent"] = (1.0f - entry.academicRatio) * 100.0f;
        metrics["lossless_verified"] = entry.losslessVerified;
        
        totalOriginalBytes += entry.originalSize;
        totalCompressedBytes += entry.binaryData.size();
    }
    
    // Overall session summary
    JsonObject sessionSummary = doc["session_summary"].to<JsonObject>();
    sessionSummary["total_original_bytes"] = totalOriginalBytes;
    sessionSummary["total_compressed_bytes"] = totalCompressedBytes;
    sessionSummary["overall_academic_ratio"] = (totalOriginalBytes > 0) ? 
        (float)totalCompressedBytes / (float)totalOriginalBytes : 1.0f;
    sessionSummary["overall_savings_percent"] = (totalOriginalBytes > 0) ? 
        (1.0f - (float)totalCompressedBytes / (float)totalOriginalBytes) * 100.0f : 0.0f;
    sessionSummary["best_ratio_achieved"] = smartStats.bestAcademicRatio;
    sessionSummary["optimal_method"] = smartStats.currentOptimalMethod;
    
    // Method usage statistics
    JsonObject methodStats = sessionSummary["method_usage"].to<JsonObject>();
    methodStats["dictionary_count"] = smartStats.dictionaryUsed;
    methodStats["temporal_count"] = smartStats.temporalUsed;
    methodStats["semantic_count"] = smartStats.semanticUsed;
    methodStats["bitpack_count"] = smartStats.bitpackUsed;
    
    char jsonString[2048];
    size_t jsonLen = serializeJson(doc, jsonString, sizeof(jsonString));

    print("UPLOADING COMPRESSED DATA TO FLASK SERVER\n");
    print("Packets: %zu | JSON Size: %zu bytes\n", allData.size(), jsonLen);
    print("Compression Summary: %zu -> %zu bytes (%.1f%% savings)\n", 
        totalOriginalBytes, totalCompressedBytes,
        (totalOriginalBytes > 0) ? (1.0f - (float)totalCompressedBytes / (float)totalOriginalBytes) * 100.0f : 0.0f);
    
    int httpResponseCode = http.POST((uint8_t*)jsonString, jsonLen);
    
    if (httpResponseCode == 200) {
        String response = http.getString();
        print("Upload successful to Flask server!\n");
        print("Server response: %s\n", response.c_str());
        smartStats.losslessSuccesses++;
    } else {
        print("Upload failed (HTTP %d)\n", httpResponseCode);
        if (httpResponseCode > 0) {
            String errorResponse = http.getString();
            print("Flask server error: %s\n", errorResponse.c_str());
        }
        print("Restoring compressed data to buffer...\n");
        
        // Restore data to buffer
        for (const auto& entry : allData) {
            smartRingBuffer.push(entry);
        }
        smartStats.compressionFailures++;
    }
    
    http.end();
}


/**
 * @fn void convertBinaryToBase64(const std::vector<uint8_t>& binaryData, char* result, size_t resultSize)
 * 
 * @brief Convert binary data to Base64 encoded string.
 * 
 * @param binaryData Input binary data as a vector of bytes.
 * @param result Output buffer to store the Base64 string.
 * @param resultSize Size of the output buffer.
 */
void convertBinaryToBase64(const std::vector<uint8_t>& binaryData, char* result, size_t resultSize) {
    const char* chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    size_t pos = 0;
    
    for (size_t i = 0; i < binaryData.size() && pos < resultSize - 5; i += 3) {
        uint32_t value = binaryData[i] << 16;
        if (i + 1 < binaryData.size()) value |= binaryData[i + 1] << 8;
        if (i + 2 < binaryData.size()) value |= binaryData[i + 2];
        
        result[pos++] = chars[(value >> 18) & 0x3F];
        result[pos++] = chars[(value >> 12) & 0x3F];
        result[pos++] = chars[(value >> 6) & 0x3F];
        result[pos++] = chars[value & 0x3F];
    }
    
    while (pos % 4 && pos < resultSize - 1) result[pos++] = '=';
    result[pos] = '\0';
}


/**
 * @fn std::vector<uint8_t> compressBatchWithSmartSelection(const SampleBatch& batch,
 *                                                   unsigned long& compressionTime,
 *                                                  char* methodUsed, size_t methodSize,
 *                                                  float& academicRatio,
 *                                                 float& traditionalRatio)
 * 
 * @brief Compress an entire batch of samples using smart selection and track performance.
 * 
 * @param batch Reference to the SampleBatch containing multiple samples.
 * @param compressionTime Reference to store the time taken for compression (in microseconds).
 * @param methodUsed Pointer to char array to store the name of the compression method used.
 * @param methodSize Size of the methodUsed char array.
 * @param academicRatio Reference to store the academic compression ratio (compressed/original).
 * @param traditionalRatio Reference to store the traditional compression ratio (original/compressed).
 * 
 * @return std::vector<uint8_t> Compressed data as a byte vector.
 */
std::vector<uint8_t> compressBatchWithSmartSelection(const SampleBatch& batch, 
                                                   unsigned long& compressionTime, 
                                                   char* methodUsed, size_t methodSize,
                                                   float& academicRatio, 
                                                   float& traditionalRatio) {
    unsigned long startTime = micros();
    
    // Convert batch to linear array
    uint16_t linearData[30];  // 5 samples × 6 values
    batch.toLinearArray(linearData);
    
    // Display original values clearly
    print("ORIGINAL SENSOR VALUES:\n");
    for (size_t i = 0; i < batch.sampleCount; i++) {
        print("Sample %zu: VAC1=%u, IAC1=%u, IPV1=%u, PAC=%u, IPV2=%u, TEMP=%u\n",
                      i+1, batch.samples[i][0], batch.samples[i][1], batch.samples[i][2],
                      batch.samples[i][3], batch.samples[i][4], batch.samples[i][5]);
    }
    
    // Create register selection array for the batch
    RegID batchSelection[30];
    const RegID singleSelection[] = {REG_VAC1, REG_IAC1, REG_IPV1, REG_PAC, REG_IPV2, REG_TEMP};
    
    for (size_t i = 0; i < batch.sampleCount; i++) {
        memcpy(batchSelection + (i * 6), singleSelection, 6 * sizeof(RegID));
    }
    
    // Use smart selection on the entire batch
    std::vector<uint8_t> compressed = DataCompression::compressWithSmartSelection(
        linearData, batchSelection, batch.sampleCount * 6);
    
    compressionTime = micros() - startTime;
    
    // Determine method from compressed data header
    if (!compressed.empty()) {
        switch (compressed[0]) {
            case 0xD0: 
                strncpy(methodUsed, "BATCH_DICTIONARY", methodSize - 1);
                smartStats.dictionaryUsed++;
                break;
            case 0x70:
            case 0x71: 
                strncpy(methodUsed, "BATCH_TEMPORAL", methodSize - 1);
                smartStats.temporalUsed++;
                break;
            case 0x50: 
                strncpy(methodUsed, "BATCH_SEMANTIC", methodSize - 1);
                smartStats.semanticUsed++;
                break;
            case 0x01:
            default:
                strncpy(methodUsed, "BATCH_BITPACK", methodSize - 1);
                smartStats.bitpackUsed++;
        }
        methodUsed[methodSize - 1] = '\0';
    } else {
        strncpy(methodUsed, "BATCH_ERROR", methodSize - 1);
        methodUsed[methodSize - 1] = '\0';
    }
    
    // Calculate compression ratios
    size_t originalSize = batch.sampleCount * 6 * sizeof(uint16_t);
    size_t compressedSize = compressed.size();
    
    academicRatio = (compressedSize > 0) ? (float)compressedSize / (float)originalSize : 1.0f;
    traditionalRatio = (compressedSize > 0) ? (float)originalSize / (float)compressedSize : 0.0f;
    
    return compressed;
}


/**
 * @fn bool readMultipleRegisters(const RegID* selection, size_t count, uint16_t* data)
 * 
 * @brief Read multiple registers from the sensor and store values in the provided array.
 * 
 * @param selection Pointer to the array of RegID indicating which registers to read.
 * @param count Number of registers to read (length of selection and data arrays).
 * @param data Pointer to the array where read register values will be stored.
 * 
 * @return bool True if read was successful and all registers were read, false otherwise.
 */
bool readMultipleRegisters(const RegID* selection, size_t count, uint16_t* data) 
{
    // Use the acquisition system to read registers
    DecodedValues result = readRequest(selection, count);
    
    // Check if we got the expected number of values
    if (result.count != count) {
        return false;
    }
    
    // Copy the register values to the output array
    for (size_t i = 0; i < count && i < result.count; i++) {
        data[i] = result.values[i];
    }
    
    return true;
}



// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/peripheral/acquisition.cpp =====
#include "peripheral/acquisition.h"

ProtocolAdapter adapter;

/**
 * @fn uint16_t calculateCRC(const uint8_t* data, int length)
 * 
 * @brief Calculate Modbus CRC16 checksum.
 * 
 * @param data Pointer to data bytes.
 * @param length Number of bytes in data.
 * 
 * @return Calculated CRC16 value.
 */
static uint16_t calculateCRC(const uint8_t* data, int length) 
{
  uint16_t crc = 0xFFFF;
  for (int i = 0; i < length; i++) 
  {
    crc ^= (data[i] & 0xFF);
    for (int j = 0; j < 8; j++) 
    {
      if (crc & 0x0001) 
      {
        crc >>= 1;
        crc ^= 0xA001;
      } 
      else 
      {
        crc >>= 1;
      }
    }
  }
  return crc & 0xFFFF;
}


/**
 * @fn bool toHex(const uint8_t* data, size_t len, char* out, size_t outSize)
 * 
 * @brief Convert binary data to hexadecimal string.
 * 
 * @param data Pointer to binary data.
 * @param len Length of binary data in bytes.
 * @param out Output buffer to receive hex string.
 * @param outSize Size of the output buffer.
 * 
 * @return true if conversion successful, false if output buffer too small.
 */
static bool toHex(const uint8_t* data, size_t len, char* out, size_t outSize) 
{
  if (outSize < (len * 2 + 1)) return false;
  for (size_t i = 0; i < len; i++) 
  {
    sprintf(out + (i * 2), "%02X", data[i]);
  }
  out[len * 2] = '\0';
  return true;
}


/**
 * @fn const RegisterDef* findRegister(RegID id)
 * 
 * @brief Find register definition by RegID.
 * 
 * @param id The RegID to look up.
 * 
 * @return Pointer to RegisterDef if found, nullptr if not found.
 */
const RegisterDef* findRegister(RegID id) 
{
  for (size_t i = 0; i < REGISTER_COUNT; i++) 
  {
    if (REGISTER_MAP[i].id == id) return &REGISTER_MAP[i];
  }
  return nullptr;
}


/**
 * @fn bool buildReadFrame(uint8_t slave, const RegID* regs, size_t regCount, uint16_t& outStart, uint16_t& outCount, char* outHex, size_t outHexSize)
 * 
 * @brief Build a Modbus read frame for a given selection of registers.
 * 
 * @param slave Inverter address (usually 0x11).
 * @param regs Array of requested RegIDs.
 * @param regCount Number of registers requested.
 * @param outStart Output parameter to receive start address of contiguous block.
 * @param outCount Output parameter to receive number of registers in block.
 * @param outHex Output buffer to receive the frame as HEX C-string (null-terminated)
 * @param outHexSize Size of the output buffer.
 * 
 * @return true if frame built successfully, false if error.
 */
bool buildReadFrame(uint8_t slave, const RegID* regs, size_t regCount, uint16_t& outStart, uint16_t& outCount, char* outHex, size_t outHexSize) 
{
  // find min/max addresses
  uint16_t start = 0xFFFF, end = 0;
  for (size_t i = 0; i < regCount; i++) 
  {
    const RegisterDef* rd = findRegister(regs[i]);
    if (!rd) continue;
    if (rd->addr < start) start = rd->addr;
    if (rd->addr > end)   end   = rd->addr;
  }
  outStart = start;
  outCount = (end - start) + 1;

  // Build Modbus frame
  uint8_t frame[8];
  frame[0] = slave;
  frame[1] = 0x03; // read holding regs
  frame[2] = (start >> 8) & 0xFF;
  frame[3] = start & 0xFF;
  frame[4] = (outCount >> 8) & 0xFF;
  frame[5] = outCount & 0xFF;

  uint16_t crc = calculateCRC(frame, 6);
  frame[6] = crc & 0xFF;
  frame[7] = (crc >> 8) & 0xFF;

  return toHex(frame, 8, outHex, outHexSize);
}


/**
 * @fn bool buildWriteFrame(uint8_t slave, uint16_t regAddr, uint16_t value, char* outHex, size_t outHexSize)
 * 
 * @brief Build a Modbus write frame to set a single register.
 * 
 * @param slave Inverter address (usually 0x11).
 * @param regAddr Register address to write.
 * @param value Value to write to the register.
 * @param outHex Output buffer to receive the frame as HEX C-string (null-terminated).
 * @param outHexSize Size of the output buffer.
 * 
 * @return true if frame built successfully, false if error.
 */
bool buildWriteFrame(uint8_t slave, uint16_t regAddr, uint16_t value, char* outHex, size_t outHexSize) 
{
  uint8_t frame[8];
  frame[0] = slave;
  frame[1] = 0x06; // write single register
  frame[2] = (regAddr >> 8) & 0xFF;
  frame[3] = regAddr & 0xFF;
  frame[4] = (value >> 8) & 0xFF;
  frame[5] = value & 0xFF;

  uint16_t crc = calculateCRC(frame, 6);
  frame[6] = crc & 0xFF;
  frame[7] = (crc >> 8) & 0xFF;

  return toHex(frame, 8, outHex, outHexSize);
}


/**
 * @fn bool setPower(uint16_t powerValue)
 * 
 * @brief Set the power output.
 * 
 * @param powerValue Power value to set.
 * 
 * @return true if power set successfully, false if error.
 */
bool setPower(uint16_t powerValue) 
{
  char frame[32];
  if (!buildWriteFrame(0x11, 8, powerValue, frame, sizeof(frame))) 
  {
    debug.log("Failed to build write frame\n");
    return false;
  }

  debug.log("Sending write frame: %s\n", frame);

  char responseFrame[128];

  bool okReq;

  if (WiFi.status() != WL_CONNECTED)
  {
    debug.log("WiFi not connected\n");
    okReq = false;
  }
  else
  {
    okReq = adapter.writeRegister(frame, responseFrame, sizeof(responseFrame));
  }

  if (!okReq) 
  {
    debug.log("Write request failed after retries.\n");
    return false;
  }

  if (strcmp(responseFrame, frame) == 0) 
  {
    debug.log("Power set to %u successfully\n", powerValue);
    return true;
  } 
  else 
  {
    debug.log("Failed to set power, response mismatch\n");
    debug.log("Raw response frame: %s\n", responseFrame);
    return false;
  }
}


/**
 * @fn DecodedValues readRequest(const RegID* regs, size_t regCount)
 * 
 * @brief Read specified registers from the inverter.
 * 
 * @param regs Array of RegIDs to read.
 * @param regCount Number of registers to read.
 * 
 * @return DecodedValues struct containing the read values or error indication.
 */
DecodedValues readRequest(const RegID* regs, size_t regCount) 
{
  adapter.setApiKey("NjhhZWIwNDU1ZDdmMzg3MzNiMTQ5YTFmOjY4YWViMDQ1NWQ3ZjM4NzMzYjE0OWExNQ==");

  DecodedValues result;
  result.count = 0;

  // build read frame
  uint16_t startAddr, count;
  char frame[64];
  if (!buildReadFrame(0x11, regs, regCount, startAddr, count, frame, sizeof(frame))) 
  {
    debug.log("Failed to build read frame.\n");
    result.values[0] = 0xFFFF; // Indicate error
    result.count = 1;
    return result;
  }

  // send request
  char responseFrame[256];
  
  bool ok;

  if (WiFi.status() != WL_CONNECTED)
  {
    debug.log("WiFi not connected\n");
    ok =  false;
  }
  else
  {
    ok = adapter.readRegister(frame, responseFrame, sizeof(responseFrame));
  }

  //if response is error return error values to main code
  if (!ok) 
  {
    debug.log("Read request failed after retries.\n");
    result.values[0] = 0xFFFF; // Indicate error
    result.count = 1;
    return result;
  }
  const char* response_frame = responseFrame;
  // decode response
  result = decodeReadResponse(response_frame, startAddr, count, regs, regCount);

  return result;
}

/**
 * @fn const uint16_t* returnValues(const DecodedValues& decoded)
 * 
 * @brief Return pointer to decoded register values array.
 * 
 * @param decoded DecodedValues struct containing the values.
 * 
 * @return Pointer to the array of decoded register values.
 */
const uint16_t* returnValues(const DecodedValues& decoded) 
{
  return decoded.values;
}


/**
 * @fn DecodedValues decodeReadResponse(const char* frameHex, uint16_t startAddr, uint16_t count, const RegID* regs, size_t regCount)
 * 
 * @brief Decode a Modbus read response frame.
 * 
 * @param frameHex Inverter response (HEX C-string).
 * @param startAddr Start of requested block.
 * @param count Number of registers read in block.
 * @param regs Array of requested RegIDs.
 * @param regCount Number of registers requested.
 * 
 * @return DecodedValues struct containing only the requested registers.
 */
DecodedValues decodeReadResponse(const char* frameHex, uint16_t startAddr, uint16_t count, const RegID* regs, size_t regCount) 
{
  DecodedValues result;
  result.count = 0;

  if (!frameHex) return result;
  size_t len = strlen(frameHex);
  if (len < 10) return result;

  char buf[3]; buf[2] = '\0';
  memcpy(buf, frameHex + 2, 2);
  uint8_t func = (uint8_t)strtol(buf, NULL, 16);
  if (func != 0x03) return result;

  memcpy(buf, frameHex + 4, 2);
  uint8_t byteCount = (uint8_t)strtol(buf, NULL, 16);
  if (byteCount != count * 2) return result;

  uint16_t allRegs[64];
  for (uint16_t i = 0; i < count; i++) 
  {
    memcpy(buf, frameHex + 6 + i*4, 2);
    uint16_t hi = (uint16_t)strtol(buf, NULL, 16);
    memcpy(buf, frameHex + 8 + i*4, 2);
    uint16_t lo = (uint16_t)strtol(buf, NULL, 16);
    allRegs[i] = (hi << 8) | lo;
  }

  for (size_t i = 0; i < regCount; i++) 
  {
    const RegisterDef* rd = findRegister(regs[i]);
    if (!rd) 
    {
      result.values[result.count++] = 0;
      continue;
    }
    result.values[result.count++] = allRegs[rd->addr - startAddr];
  }

  return result;
}

// ===== /Users/prabathwijethilaka/Sem7/Embedded/EcoWatt_TeamPowerPort/PIO/ECOWATT/src/peripheral/arduino_wifi.cpp =====
#include "peripheral/arduino_wifi.h"

Arduino_Wifi::Arduino_Wifi() {};


/**
 * @fn void Arduino_Wifi::begin()
 * 
 * @brief Initialize WiFi connection with stored SSID and password.
 */
void Arduino_Wifi::begin() 
{
  // Serial.begin(115200);
  WiFi.begin(ssid, password);

  debug.log("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) 
  {
    wait.ms(500);
    debug.log(".");
  }
  debug.log("\rConnected!\n");
}


// Setters 

/**
 * @fn void Arduino_Wifi::setSSID(const char* newSSID)
 * 
 * @brief Set the WiFi SSID.
 * 
 * @param newSSID The new SSID to set.
 */
void Arduino_Wifi::setSSID(const char* newSSID) 
{ 
  ssid = newSSID; 
}


/**
 * @fn void Arduino_Wifi::setPassword(const char* newPassword)
 * 
 * @brief Set the WiFi password.
 * 
 * @param newPassword The new password to set.
 */
void Arduino_Wifi::setPassword(const char* newPassword) 
{ 
  password = newPassword; 
}


// Getters

/**
 * @fn const char* Arduino_Wifi::getSSID()
 * 
 * @brief Get the stored WiFi SSID.
 * 
 * @return The stored SSID.
 */
const char* Arduino_Wifi::getSSID() 
{ 
  return ssid; 
}


/**
 * @fn const char* Arduino_Wifi::getPassword()
 * 
 * @brief Get the stored WiFi password.
 * 
 * @return The stored password.
 */
const char* Arduino_Wifi::getPassword() 
{ 
  return password; 
}

